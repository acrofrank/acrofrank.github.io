{"title":"（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（二）","slug":"remix-explain-translate-computer-related-vocabulary-git1","date":"2018-10-16T00:14:52.000Z","updated":"2019-11-15T04:49:23.734Z","comments":true,"path":"api/articles/remix-explain-translate-computer-related-vocabulary-git1.json","excerpt":" [Remix]说文解字–计算机相关词汇–Git相关 (Remix)Explain and translate computer-related vocabulary 计算机中那些单词的故事——Git系列（二）声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态 ✓ 0x00 Git 历史与简介提到 Git 就离不开版本控制，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。 版本控制系统大致可以分为：1.本地版本控制系统2.集中化的版本控制系统3.分布式版本控制系统1.本地版本控制系统问题：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的<br>好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。","covers":["/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/本地版本控制f1.png"],"content":"<!-- build time:Tue Dec 10 2019 05:30:20 GMT+0800 (GMT+08:00) --><h1 id=\"remix说文解字计算机相关词汇git相关\"><a class=\"markdownIt-Anchor\" href=\"#remix说文解字计算机相关词汇git相关\"></a> [Remix]说文解字–计算机相关词汇–Git相关</h1><h2 id=\"remixexplain-and-translate-computer-related-vocabulary\"><a class=\"markdownIt-Anchor\" href=\"#remixexplain-and-translate-computer-related-vocabulary\"></a> (Remix)Explain and translate computer-related vocabulary</h2><h2 id=\"计算机中那些单词的故事git系列二\"><a class=\"markdownIt-Anchor\" href=\"#计算机中那些单词的故事git系列二\"></a> 计算机中那些单词的故事——Git系列（二）</h2><p><code>声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。</code></p><p>本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态</p><h3 id=\"0x00-git-历史与简介\"><a class=\"markdownIt-Anchor\" href=\"#0x00-git-历史与简介\"></a> ✓ 0x00 Git 历史与简介</h3><p>提到 <strong>Git</strong> 就离不开版本控制，<strong>版本控制</strong><em>是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</em></p><blockquote><p>[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。</p></blockquote><h4 id=\"版本控制系统大致可以分为\"><a class=\"markdownIt-Anchor\" href=\"#版本控制系统大致可以分为\"></a> 版本控制系统大致可以分为：</h4><p><a href=\"#1.1\">1.本地版本控制系统</a></p><p><a href=\"#1.2\">2.集中化的版本控制系统</a></p><p><a href=\"#1.3\">3.分布式版本控制系统</a></p><p><strong><span id=\"1.1\">1.本地版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的<br>好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><a id=\"more\"></a> <img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/本地版本控制f1.png\" width=\"300\" height=\"300\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：应用某种简单的数据库来记录文件的历次更新差异。</p></blockquote><p><strong><span id=\"1.2\">2.集中化的版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统<br>（<em>Centralized Version Control Systems</em>，简称 <strong>CVCS</strong>）应运而生。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/集中化的版本控制f2.png\" width=\"350\" height=\"350\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p></blockquote><p><strong><span id=\"1.3\">3.分布式版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。</p><blockquote><p>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p></blockquote><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/分布式版本控制f3.png\" width=\"400\" height=\"400\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：分布式版本控制系统（<em><strong>Distributed Version Control System</strong></em>，简称 <strong>DVCS</strong>）能够完美解决集中管理系统的问题。像_<strong>Git</strong>_、<strong><em>Mercurial</em></strong>、<strong><em>Bazaar</em></strong> 以及 <strong><em>Darcs</em></strong> 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p><blockquote><p>[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。</p></blockquote></blockquote><h4 id=\"git相比其他版本控制系统的优势\"><a class=\"markdownIt-Anchor\" href=\"#git相比其他版本控制系统的优势\"></a> <strong>Git相比其他版本控制系统的优势</strong></h4><p><a href=\"#2.1\">1.Git 直接记录快照，而非差异比较</a></p><p><a href=\"#2.2\">2.Git 近乎所有操作都是本地执行</a></p><p><a href=\"#2.3\">3.Git 保证完整性</a></p><p><a href=\"#2.4\">4.Git 一般只添加数据</a></p><p><strong><span id=\"2.1\">1.Git 直接记录快照，而非差异比较</span></strong></p><blockquote><p>Git 和其它版本控制系统（包括 <strong>Subversion</strong> 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（<strong>CVS、Subversion、Perforce、Bazaar</strong> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储每个文件与初始版本的差异f5.png\" width=\"450\" height=\"250\" alt=\"存储每个文件与初始版本的差异\" align=\"center\"><p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储项目随时间改变的快照f5.png\" width=\"450\" height=\"250\" alt=\"存储项目随时间改变的快照\" align=\"center\"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。</p><blockquote><p>[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子</p></blockquote></blockquote><p><strong><span id=\"2.2\">2.Git 近乎所有操作都是本地执行</span></strong></p><blockquote><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><blockquote><p>[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。</p></blockquote></blockquote><p><strong><span id=\"2.3\">3.Git 保证完整性</span></strong></p><blockquote><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<strong>这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学</strong>。若你在传送过程中丢失信息或损坏文件，Git 也能发现。</p><p>Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内<br>容的哈希值来索引，而不是文件名。</p><blockquote><p>24b9da6552252987aa493b52f8696cd6d3b00373</p></blockquote><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></blockquote><p><strong><span id=\"2.4\">4.Git 一般只添加数据</span></strong></p><blockquote><p>执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><blockquote><p>[P.S] <strong>Git</strong> 和系统编程的极客和大牛脱不开关系</p></blockquote></blockquote><h4 id=\"git本地的三种状态\"><a class=\"markdownIt-Anchor\" href=\"#git本地的三种状态\"></a> Git本地的三种状态</h4><blockquote><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交（committed）、已修改（modified）和已暂存（staged）</strong>。<strong>已提交</strong>表示数据已经安全的保存在本地数据库中。<strong>已修改</strong>表示修改了文件，但还没保存到数据库中。<strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>有状态变量就会有状态空间，Git项目的三个工作区域的概念：<strong>工作目录</strong>、<strong>Git仓库</strong>以及<strong>暂存区域</strong>。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/工作目录、暂存区域以及Git仓库f6.png\" width=\"450\" height=\"250\" alt=\"工作目录、暂存区域以及Git仓库\" align=\"center\"><p><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域</p><p><strong>Git仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p></blockquote><h5 id=\"基本的git工作流程如下\"><a class=\"markdownIt-Anchor\" href=\"#基本的git工作流程如下\"></a> 基本的Git工作流程如下：</h5><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><blockquote><p>如果 Git 目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>。</p><p>[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。</p></blockquote><h3 id=\"0x01-git-中的单词-附\"><a class=\"markdownIt-Anchor\" href=\"#0x01-git-中的单词-附\"></a> ✓ 0x01 Git 中的单词 (附)</h3><h4 id=\"git-help\"><a class=\"markdownIt-Anchor\" href=\"#git-help\"></a> <strong>git --help</strong></h4><blockquote><p><strong>add</strong> – Add file contents to the index</p><p><strong>bisect</strong> – Find by binary search the change that introduced a bug</p><p><strong>branch</strong> – List, create, or delete branches</p><p><strong>checkout</strong> – Checkout a branch or paths to the working tree</p><p><strong>clone</strong> – Clone a repository into a new directory</p><p><strong>commit</strong> – Record changes to the repository</p><p><strong>diff</strong> – Show changes between commits, commit and working tree, etc</p><p><strong>fetch</strong> – Download objects and refs from another repository</p><p><strong>grep</strong> – Print lines matching a pattern</p><p><strong>init</strong> – Create an empty Git repository or reinitialize an existing one</p><p><strong>log</strong> – Show commit logs</p><p><strong>merge</strong> – Join two or more development histories together</p><p><strong>mv</strong> – Move or rename a file, a directory, or a symlink</p><p><strong>pull</strong> – Fetch from and merge with another repository or a local branch</p><p><strong>push</strong> – Update remote refs along with associated objects</p><p><strong>rebase</strong> – Forward-port local commits to the updated upstream head</p><p><strong>reset</strong> – Reset current HEAD to the specified state</p><p><strong>rm</strong> – Remove files from the working tree and from the index</p><p><strong>show</strong> – Show various types of objects</p><p><strong>status</strong> – Show the working tree status</p><p><strong>tag</strong> – Create, list, delete or verify a tag object signed with GPG</p></blockquote><h4 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\"></a> 参考文献</h4><p>[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress<br>[2] Manual of Git</p><!-- rebuild by neat -->","more":"<img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/本地版本控制f1.png\" width=\"300\" height=\"300\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：应用某种简单的数据库来记录文件的历次更新差异。</p><p><strong><span id=\"1.2\">2.集中化的版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统<br>（<em>Centralized Version Control Systems</em>，简称 <strong>CVCS</strong>）应运而生。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/集中化的版本控制f2.png\" width=\"350\" height=\"350\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p></blockquote><p><strong><span id=\"1.3\">3.分布式版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。</p><blockquote><p>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p></blockquote><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/分布式版本控制f3.png\" width=\"400\" height=\"400\" alt=\"图片名称\" align=\"center\"><p><strong>解决办法</strong>：分布式版本控制系统（<em><strong>Distributed Version Control System</strong></em>，简称 <strong>DVCS</strong>）能够完美解决集中管理系统的问题。像_<strong>Git</strong>_、<strong><em>Mercurial</em></strong>、<strong><em>Bazaar</em></strong> 以及 <strong><em>Darcs</em></strong> 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p><blockquote><p>[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。</p></blockquote></blockquote><h4 id=\"git相比其他版本控制系统的优势\"><a class=\"markdownIt-Anchor\" href=\"#git相比其他版本控制系统的优势\"></a> <strong>Git相比其他版本控制系统的优势</strong></h4><p><a href=\"#2.1\">1.Git 直接记录快照，而非差异比较</a></p><p><a href=\"#2.2\">2.Git 近乎所有操作都是本地执行</a></p><p><a href=\"#2.3\">3.Git 保证完整性</a></p><p><a href=\"#2.4\">4.Git 一般只添加数据</a></p><p><strong><span id=\"2.1\">1.Git 直接记录快照，而非差异比较</span></strong></p><blockquote><p>Git 和其它版本控制系统（包括 <strong>Subversion</strong> 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（<strong>CVS、Subversion、Perforce、Bazaar</strong> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储每个文件与初始版本的差异f5.png\" width=\"450\" height=\"250\" alt=\"存储每个文件与初始版本的差异\" align=\"center\"><p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储项目随时间改变的快照f5.png\" width=\"450\" height=\"250\" alt=\"存储项目随时间改变的快照\" align=\"center\"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。</p><blockquote><p>[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子</p></blockquote></blockquote><p><strong><span id=\"2.2\">2.Git 近乎所有操作都是本地执行</span></strong></p><blockquote><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><blockquote><p>[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。</p></blockquote></blockquote><p><strong><span id=\"2.3\">3.Git 保证完整性</span></strong></p><blockquote><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<strong>这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学</strong>。若你在传送过程中丢失信息或损坏文件，Git 也能发现。</p><p>Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内<br>容的哈希值来索引，而不是文件名。</p><blockquote><p>24b9da6552252987aa493b52f8696cd6d3b00373</p></blockquote><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></blockquote><p><strong><span id=\"2.4\">4.Git 一般只添加数据</span></strong></p><blockquote><p>执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><blockquote><p>[P.S] <strong>Git</strong> 和系统编程的极客和大牛脱不开关系</p></blockquote></blockquote><h4 id=\"git本地的三种状态\"><a class=\"markdownIt-Anchor\" href=\"#git本地的三种状态\"></a> Git本地的三种状态</h4><blockquote><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交（committed）、已修改（modified）和已暂存（staged）</strong>。<strong>已提交</strong>表示数据已经安全的保存在本地数据库中。<strong>已修改</strong>表示修改了文件，但还没保存到数据库中。<strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>有状态变量就会有状态空间，Git项目的三个工作区域的概念：<strong>工作目录</strong>、<strong>Git仓库</strong>以及<strong>暂存区域</strong>。</p><img src=\"/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/工作目录、暂存区域以及Git仓库f6.png\" width=\"450\" height=\"250\" alt=\"工作目录、暂存区域以及Git仓库\" align=\"center\"><p><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域</p><p><strong>Git仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p></blockquote><h5 id=\"基本的git工作流程如下\"><a class=\"markdownIt-Anchor\" href=\"#基本的git工作流程如下\"></a> 基本的Git工作流程如下：</h5><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><blockquote><p>如果 Git 目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>。</p><p>[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。</p></blockquote><h3 id=\"0x01-git-中的单词-附\"><a class=\"markdownIt-Anchor\" href=\"#0x01-git-中的单词-附\"></a> ✓ 0x01 Git 中的单词 (附)</h3><h4 id=\"git-help\"><a class=\"markdownIt-Anchor\" href=\"#git-help\"></a> <strong>git --help</strong></h4><blockquote><p><strong>add</strong> – Add file contents to the index</p><p><strong>bisect</strong> – Find by binary search the change that introduced a bug</p><p><strong>branch</strong> – List, create, or delete branches</p><p><strong>checkout</strong> – Checkout a branch or paths to the working tree</p><p><strong>clone</strong> – Clone a repository into a new directory</p><p><strong>commit</strong> – Record changes to the repository</p><p><strong>diff</strong> – Show changes between commits, commit and working tree, etc</p><p><strong>fetch</strong> – Download objects and refs from another repository</p><p><strong>grep</strong> – Print lines matching a pattern</p><p><strong>init</strong> – Create an empty Git repository or reinitialize an existing one</p><p><strong>log</strong> – Show commit logs</p><p><strong>merge</strong> – Join two or more development histories together</p><p><strong>mv</strong> – Move or rename a file, a directory, or a symlink</p><p><strong>pull</strong> – Fetch from and merge with another repository or a local branch</p><p><strong>push</strong> – Update remote refs along with associated objects</p><p><strong>rebase</strong> – Forward-port local commits to the updated upstream head</p><p><strong>reset</strong> – Reset current HEAD to the specified state</p><p><strong>rm</strong> – Remove files from the working tree and from the index</p><p><strong>show</strong> – Show various types of objects</p><p><strong>status</strong> – Show the working tree status</p><p><strong>tag</strong> – Create, list, delete or verify a tag object signed with GPG</p></blockquote><h4 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\"></a> 参考文献</h4><p>[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress<br>[2] Manual of Git</p><!-- rebuild by neat -->","categories":[{"name":"朝花夕拾","path":"api/categories/朝花夕拾.json"}],"tags":[{"name":"计算机","path":"api/tags/计算机.json"},{"name":"词汇","path":"api/tags/词汇.json"},{"name":"英语","path":"api/tags/英语.json"},{"name":"git","path":"api/tags/git.json"},{"name":"workflow","path":"api/tags/workflow.json"}]}