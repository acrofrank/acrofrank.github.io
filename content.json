{"meta":{"title":"MYBLOG","subtitle":"","description":"MyBlog","author":"Acrofrank","url":"http://acrofrank.github.io","root":"/"},"pages":[{"title":"About","date":"un00fin00","updated":"un00fin00","comments":true,"path":"about/index.html","permalink":"http://acrofrank.github.io/about/index.html","excerpt":"","text":"个人介绍遨游在数理的汪洋之中，兼具INTP/ISTP人格，模型化思考，具有工程思维，乐于钻研，技术导向，热爱技术，善于通过网络搜索和读书扩展自己认知。欢迎留言写下你爱读的书！"},{"title":"书单","date":"un00fin00","updated":"un00fin00","comments":false,"path":"books/index.html","permalink":"http://acrofrank.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"un00fin00","updated":"un00fin00","comments":false,"path":"categories/index.html","permalink":"http://acrofrank.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"un00fin00","updated":"un00fin00","comments":true,"path":"links/index.html","permalink":"http://acrofrank.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"un00fin00","updated":"un00fin00","comments":true,"path":"repository/index.html","permalink":"http://acrofrank.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"un00fin00","updated":"un00fin00","comments":false,"path":"tags/index.html","permalink":"http://acrofrank.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"log_spider_project_0","slug":"log-spider-project-0","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/12/03/log-spider-project-0/","link":"","permalink":"http://acrofrank.github.io/2019/12/03/log-spider-project-0/","excerpt":"爬虫项目记录–搜索引擎图片爬取 Log my v2ex – crawl pic from SE (0) 记录爬虫项目 – 爬取搜索引擎图片（0）前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。 ✓ 0x00 关于爬虫的认识 1. 工程化的爬虫用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。常见的爬虫框架有很多，如下：开源的Web爬虫","text":"爬虫项目记录–搜索引擎图片爬取 Log my v2ex – crawl pic from SE (0) 记录爬虫项目 – 爬取搜索引擎图片（0）前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。 ✓ 0x00 关于爬虫的认识 1. 工程化的爬虫用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。常见的爬虫框架有很多，如下：开源的Web爬虫项目名开发语言平台HeritrixJavaLinuxNutchJavaCross-platformScrapyPythonCross-platformDataparkSearchC++Cross-platformHeadless chrome crawlernodejsCollyGolangCross-platformGNU WgetCLinuxGRUBC#, C, Python, PerlCross-platformht://DigC++UnixHTTrackC/C++Cross-platformICDL CrawlerC++Cross-platformmnoGoSearchCWindows其中，python栈的Scrapy，Java栈的Nutch，Golang栈的Colly， 以及Linux平台的wget想必爬虫工程师基本都有所耳闻。wget通常只是在Linux上测试环境，或者应用做一些运维方向的包下载。对比Scrapy和Nutch就很有意思了，Scrapy是python语言的，秉承python的便捷性，能沟通快速、简单、可扩展的方式去抓取你的网页内容。Nutch是老大哥Apache旗下的成熟的爬虫框架，通常结合Solr索引数据，能够实现简易的搜索引擎。PS: 之前工作应用Scrapy有段时间，其实关于Scrapy也好很多弊端都是语言上的弊端，毕竟python是解释性语言， 对机器的使用效率肯定没有java高。但是个人觉得Scrapy的设计和实现确实能够满足日常需求。通常玩Python 有个问题就是所谓动态一时爽，重构火葬场。其实这句话在Scrapy的代码上也有体现。尤其是在为了增加各种 插件，效率更是惨不忍睹。Twisted作为事件驱动引擎并发性也并没有那么高效。虽然支持扩展，通常业界都是 redis-scrapy消息队列的通信方式进行分布式爬虫，这块可能也是python的弊端，python虽然是胶水语言， 但是，个人感觉在分布式的领域，python真的不是很擅长。 （以上个人观点） 通常的爬虫框架都具备了如下特点：为了更快速获取到相应数据，爬虫都具有分布式的可扩展性；会应用语言栈中相对高并发的网络的框架去支撑爬虫引擎，提升请求效率； ✓ 0x01 关于爬虫的设计其实上文提到了要么提高单个应用的网络并发提高网络请求，要么通过分布式的方式调度单体程序，实现提高请求数量。除了这些，能够保证爬虫的完成工作在实际工况下还不能够满足需求。因为现实情况并不是网络爬虫总能爬取到我们想要的数据。要考虑各种爬虫的异常情况，以增加爬虫的健壮性。因此需要明确爬虫成功获取数据都经历了哪些流程，并且需要对这些流程进行监控。 1. 爬虫执行任务的流程模型获取任务（需要被请求的资源地址）目标网站发送请求获取目标网站返回数据解析目标网站返回数据持久化的数据PS: 深挖一些，其实23可以抽象一个模块；其中涉及到一些问题，比如，一个网页的数据并不是直接以静态页或者接口数据的形势返回给爬虫，存在动态页的情况。需要加载js和多次请求才能完成需要持久化的数据，这其中变化比较大。还有可能就是，需要解析并下载视频资源或音频资源或者图片资源。还有可能需要与其他服务配合获取数据，比如通过MITM截取的数据组合可以作为这个阶段要持久化的数据。总之，23过程可以看做是爬虫系统和网页之间交互的过程，最终输出结果是需求的数据。 2. 爬虫执行任务的状态模型有动作，即为有变化，有变化就会有变化的状态空间，就要能够记录其中的状态。其实以爬虫为例，通常都会记录以上1~5个过程，不考虑特殊聚合数据的情况【js渲染， MITM组合数据】，会根据上述过程进行记录。通常记录过程完成态即可（成功/失败的统计数据），还有完成态的时间。此外，爬虫通常和代理是分不开的。所以，通常也会记录代理的使用情况。以scrapy为例如下：{'downloader/request_bytes': 212, 'downloader/request_count': 1, 'downloader/request_method_count/GET': 1, 'downloader/response_bytes': 1476, 'downloader/response_count': 1, 'downloader/response_status_count/200': 1, 'elapsed_time_seconds': 0.160045, 'finish_reason': 'finished', 'finish_time': datetime.datetime(2019, 12, 9, 20, 54, 6, 134329), 'log_count/DEBUG': 1, 'log_count/INFO': 10, 'memusage/max': 44896256, 'memusage/startup': 44896256, 'response_received_count': 1, 'scheduler/dequeued': 1, 'scheduler/dequeued/memory': 1, 'scheduler/enqueued': 1, 'scheduler/enqueued/memory': 1, 'start_time': datetime.datetime(2019, 12, 9, 20, 54, 5, 974284)} 3. 爬虫去重提高爬虫效率，爬虫的去重是必不可少的模块。此时需要区分爬虫是否为增量爬虫，若为增量爬虫，那么去重的粒度就会低一些，或者说去重集合的元素是有存活期的。非增量爬虫，就需要对所有资源进行去重，不仅仅有网页的URL，同时，网页上的资源如果下载也需要进行去重判断。去重设计也有很多种：Bloomfilter 布隆过滤器（优点：节省空间， 缺点：难以复原去重源数据，不能操作过期时间）redis Hset Set（Hset 相对 Set 节省点空间，难以操作过期时间） 参考Python有哪些常见的、好用的爬虫框架？爬虫那些事－爬虫设计思路","categories":[{"name":"工程","slug":"工程","permalink":"http://acrofrank.github.io/categories/%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://acrofrank.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"项目","slug":"项目","permalink":"http://acrofrank.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"设计","slug":"设计","permalink":"http://acrofrank.github.io/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"Spider","slug":"Spider","permalink":"http://acrofrank.github.io/tags/Spider/"},{"name":"搜索","slug":"搜索","permalink":"http://acrofrank.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"2019-2020读书清单","slug":"booklist-20191126","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2019/11/26/booklist-20191126/","link":"","permalink":"http://acrofrank.github.io/2019/11/26/booklist-20191126/","excerpt":"TODO LIST–技术书籍 2019-2020 月度需要读完的书籍清单目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。 ✓ 0x00 核心阅读 Linux-UNIX系统编程手册（上、下册）主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。 鸟哥私房菜一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。","text":"TODO LIST–技术书籍 2019-2020 月度需要读完的书籍清单目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。 ✓ 0x00 核心阅读 Linux-UNIX系统编程手册（上、下册）主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。 鸟哥私房菜一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。 Docker 容器与容器云（第2版）浙大SEL实验室出品的书。感觉应该是国内最早接触Docker相关技术的一批学院风的人们编写的。所以从溯源的角度去系统性了解下。 (纪念版) Kubernetes权威指南 从Docker到Kubernetes实践全接触主要目标：作为实践应用指导 网络暂时还是碎片化的知识，暂时没什么计划，网络相关的总是很繁杂。继续寻找通信相关的能够激发网络设计思考的书籍。 ✓ 0x01 扩展阅读之前在搞人人后端的时候，因为搞了段C++接触到中科大的编译系统透视：图解编译原理这本书，扩展这本书的团队新设计出版的相关书籍还是很能解决当下自身面对的问题，所以继续扩展研究新设计团队出版的资料。有人说30岁之后就不在适合系统学习了，所以趁着机会抓紧积累。 编译系统透视：图解编译原理页数较多，但是自己坚持读完。其实光是看完前100页就已经收益匪浅了。 Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理还没有读，暂时作为交叉阅读系统编程手册的原理延伸阅读。 ✓ 0x02 其他阅读 Git系列虽然明确Git的基本操作，还是希望结合文件系统深入认识下Git。说来最近也是巧了，在看肖臻老师讲区块链的视频，意识到Merkle Tree对分布式效验的重要性。深刻感受到现在知识在网络上传播的便捷性。继续进行深化交叉阅读提高认识吧。It was the best of times, it was the worst of times. – A Tale of Two Cities","categories":[{"name":"书籍","slug":"书籍","permalink":"http://acrofrank.github.io/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"学习","slug":"学习","permalink":"http://acrofrank.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"书籍","slug":"书籍","permalink":"http://acrofrank.github.io/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"清单","slug":"清单","permalink":"http://acrofrank.github.io/tags/%E6%B8%85%E5%8D%95/"},{"name":"计划","slug":"计划","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E5%88%92/"}]},{"title":"说文解字计算机中的词汇--单词的故事系列--analog","slug":"explain-translate-computer-related-vocabulary-analog","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2018/11/10/explain-translate-computer-related-vocabulary-analog/","link":"","permalink":"http://acrofrank.github.io/2018/11/10/explain-translate-computer-related-vocabulary-analog/","excerpt":"说文解字–计算机相关词汇 Explain and translate computer-related vocabulary 计算机中那些单词的故事——analog/模拟 ✓ 0x00 词根词源 ana-汉：来源于希腊语，意为:“up”(anabatic),“back”(anagram),“again”(analects),“throughout”(analyze),“intensive” (anatomy)等，变化型an-。","text":"说文解字–计算机相关词汇 Explain and translate computer-related vocabulary 计算机中那些单词的故事——analog/模拟 ✓ 0x00 词根词源 ana-汉：来源于希腊语，意为:“up”(anabatic),“back”(anagram),“again”(analects),“throughout”(analyze),“intensive” (anatomy)等，变化型an-。英：before verbs an-, prefix meaning“upward,”“back, backward, against,”“again, anew,” from Greek ana- “up to, toward, exceedingly, back, against,” from ana “up, on, upon, throughout, again,” cognate with Old English on, from PIE root *ano- “on, upon, above” (see on). analogue (n.) ~ analog1826, “an analogous thing,” from French analogue, from Greek analogon (itself used in English from c.1810), from ana “up to” (see ana-) + logos “account, ratio” (see lecture (n.)). Computing sense is recorded from 1946. ✓ 0x01 计算机相关领域操作系统：模拟在计算机体系中的概念：模拟：用软件的方法在一台现有的计算机（称为宿主机）上实现另一台计算机（称为虚拟机）的指令系统。数字电路方向（广义）：模拟是对真实事物或者过程的虚拟。模拟要表现出选定的物理系统或抽象系统的关键特性。模拟的关键问题包括有效信息的获取、关键特性和表现的选定、近似简化和假设的应用，以及模拟的重现度和有效性。可以认为仿真是一种重现系统外在表现的特殊的模拟。","categories":[{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"http://acrofrank.github.io/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"词汇","slug":"词汇","permalink":"http://acrofrank.github.io/tags/%E8%AF%8D%E6%B1%87/"},{"name":"英语","slug":"英语","permalink":"http://acrofrank.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（二）","slug":"remix-explain-translate-computer-related-vocabulary-git1","date":"un22fin22","updated":"un55fin55","comments":true,"path":"2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/","link":"","permalink":"http://acrofrank.github.io/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/","excerpt":"[Remix]说文解字–计算机相关词汇–Git相关 (Remix)Explain and translate computer-related vocabulary 计算机中那些单词的故事——Git系列（二）声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态 ✓ 0x00 Git 历史与简介提到 Git 就离不开版本控制，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。 版本控制系统大致可以分为：1.本地版本控制系统2.集中化的版本控制系统3.分布式版本控制系统1.本地版本控制系统问题：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。","text":"[Remix]说文解字–计算机相关词汇–Git相关 (Remix)Explain and translate computer-related vocabulary 计算机中那些单词的故事——Git系列（二）声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态 ✓ 0x00 Git 历史与简介提到 Git 就离不开版本控制，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。 版本控制系统大致可以分为：1.本地版本控制系统2.集中化的版本控制系统3.分布式版本控制系统1.本地版本控制系统问题：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。 解决办法：应用某种简单的数据库来记录文件的历次更新差异。2.集中化的版本控制系统问题：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。解决办法：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。3.分布式版本控制系统问题：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。解决办法：分布式版本控制系统（Distributed Version Control System，简称 DVCS）能够完美解决集中管理系统的问题。像_Git_、Mercurial、Bazaar 以及 Darcs 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。 Git相比其他版本控制系统的优势1.Git 直接记录快照，而非差异比较2.Git 近乎所有操作都是本地执行3.Git 保证完整性4.Git 一般只添加数据1.Git 直接记录快照，而非差异比较Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子2.Git 近乎所有操作都是本地执行在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。3.Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学。若你在传送过程中丢失信息或损坏文件，Git 也能发现。Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。24b9da6552252987aa493b52f8696cd6d3b00373Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。4.Git 一般只添加数据执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。[P.S] Git 和系统编程的极客和大牛脱不开关系 Git本地的三种状态Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。有状态变量就会有状态空间，Git项目的三个工作区域的概念：工作目录、Git仓库以及暂存区域。工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域Git仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 基本的Git工作流程如下：在工作目录中修改文件。暂存文件，将文件的快照放入暂存区域。提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。如果 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。 ✓ 0x01 Git 中的单词 (附) git --helpadd – Add file contents to the indexbisect – Find by binary search the change that introduced a bugbranch – List, create, or delete branchescheckout – Checkout a branch or paths to the working treeclone – Clone a repository into a new directorycommit – Record changes to the repositorydiff – Show changes between commits, commit and working tree, etcfetch – Download objects and refs from another repositorygrep – Print lines matching a patterninit – Create an empty Git repository or reinitialize an existing onelog – Show commit logsmerge – Join two or more development histories togethermv – Move or rename a file, a directory, or a symlinkpull – Fetch from and merge with another repository or a local branchpush – Update remote refs along with associated objectsrebase – Forward-port local commits to the updated upstream headreset – Reset current HEAD to the specified staterm – Remove files from the working tree and from the indexshow – Show various types of objectsstatus – Show the working tree statustag – Create, list, delete or verify a tag object signed with GPG 参考文献[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress[2] Manual of Git","categories":[{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"http://acrofrank.github.io/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"词汇","slug":"词汇","permalink":"http://acrofrank.github.io/tags/%E8%AF%8D%E6%B1%87/"},{"name":"英语","slug":"英语","permalink":"http://acrofrank.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"git","slug":"git","permalink":"http://acrofrank.github.io/tags/git/"},{"name":"workflow","slug":"workflow","permalink":"http://acrofrank.github.io/tags/workflow/"}]},{"title":"（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（一）","slug":"remix-explain-translate-computer-related-vocabulary-git","date":"un11fin11","updated":"un55fin55","comments":true,"path":"2018/10/15/remix-explain-translate-computer-related-vocabulary-git/","link":"","permalink":"http://acrofrank.github.io/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/","excerpt":"[Remix]说文解字–计算机相关词汇–Git相关 (Remix)Explain and translate computer-related vocabulary 计算机中那些单词的故事——Git系列(一)声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态 ✓ 0x00 Git 历史与简介提到 Git 就离不开版本控制，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。 版本控制系统大致可以分为：1.本地版本控制系统2.集中化的版本控制系统3.分布式版本控制系统1.本地版本控制系统问题：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。","text":"[Remix]说文解字–计算机相关词汇–Git相关 (Remix)Explain and translate computer-related vocabulary 计算机中那些单词的故事——Git系列(一)声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态 ✓ 0x00 Git 历史与简介提到 Git 就离不开版本控制，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。 版本控制系统大致可以分为：1.本地版本控制系统2.集中化的版本控制系统3.分布式版本控制系统1.本地版本控制系统问题：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。 解决办法：应用某种简单的数据库来记录文件的历次更新差异。2.集中化的版本控制系统问题：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。解决办法：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。3.分布式版本控制系统问题：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。解决办法：分布式版本控制系统（Distributed Version Control System，简称 DVCS）能够完美解决集中管理系统的问题。像_Git_、Mercurial、Bazaar 以及 Darcs 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。 Git相比其他版本控制系统的优势1.Git 直接记录快照，而非差异比较2.Git 近乎所有操作都是本地执行3.Git 保证完整性4.Git 一般只添加数据1.Git 直接记录快照，而非差异比较Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子2.Git 近乎所有操作都是本地执行在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。3.Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学。若你在传送过程中丢失信息或损坏文件，Git 也能发现。Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。24b9da6552252987aa493b52f8696cd6d3b00373Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。4.Git 一般只添加数据执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。[P.S] Git 和系统编程的极客和大牛脱不开关系 Git本地的三种状态Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。有状态变量就会有状态空间，Git项目的三个工作区域的概念：工作目录、Git仓库以及暂存区域。工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域Git仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 基本的Git工作流程如下：在工作目录中修改文件。暂存文件，将文件的快照放入暂存区域。提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。如果 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。 ✓ 0x01 Git 中的单词 (附) git --helpadd – Add file contents to the indexbisect – Find by binary search the change that introduced a bugbranch – List, create, or delete branchescheckout – Checkout a branch or paths to the working treeclone – Clone a repository into a new directorycommit – Record changes to the repositorydiff – Show changes between commits, commit and working tree, etcfetch – Download objects and refs from another repositorygrep – Print lines matching a patterninit – Create an empty Git repository or reinitialize an existing onelog – Show commit logsmerge – Join two or more development histories togethermv – Move or rename a file, a directory, or a symlinkpull – Fetch from and merge with another repository or a local branchpush – Update remote refs along with associated objectsrebase – Forward-port local commits to the updated upstream headreset – Reset current HEAD to the specified staterm – Remove files from the working tree and from the indexshow – Show various types of objectsstatus – Show the working tree statustag – Create, list, delete or verify a tag object signed with GPG 参考文献[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress[2] Manual of Git","categories":[{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"http://acrofrank.github.io/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"词汇","slug":"词汇","permalink":"http://acrofrank.github.io/tags/%E8%AF%8D%E6%B1%87/"},{"name":"英语","slug":"英语","permalink":"http://acrofrank.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"git","slug":"git","permalink":"http://acrofrank.github.io/tags/git/"},{"name":"workflow","slug":"workflow","permalink":"http://acrofrank.github.io/tags/workflow/"}]},{"title":"说文解字计算机中的词汇--单词的故事系列--pod","slug":"explain-translate-computer-related-vocabulary-pod","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2018/10/10/explain-translate-computer-related-vocabulary-pod/","link":"","permalink":"http://acrofrank.github.io/2018/10/10/explain-translate-computer-related-vocabulary-pod/","excerpt":"说文解字–计算机相关词汇 Explain and translate computer-related vocabulary 计算机中那些单词的故事——pod/-pod-(豌豆荚/足) ✓ 0x00 词根词源 1.pod (n.1)“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。","text":"说文解字–计算机相关词汇 Explain and translate computer-related vocabulary 计算机中那些单词的故事——pod/-pod-(豌豆荚/足) ✓ 0x00 词根词源 1.pod (n.1)“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。 2.词根ped(pod,pus,peach,patch,pet) = foot（足）1.impediment（把脚放在里面im&lt;in(=in) + ped(=foot)）n.妨碍，障碍；（口吃等）语言障碍impede v.妨碍，阻碍impedimenta n.（行李等）妨碍行进的重负Overcrowded,uncomfortable classrooms are an impediment to learning .过于拥挤的、不舒适的教室会妨碍学习。2.expedite（将脚向外迈ex(=out) + ped(foot)）vt.促进，加速（行动、进程等）快速执行，迅速处理expedition n.探险（队），远征（队）；迅速，敏捷expeditionary adj.探险的，远征的expeditious 敏捷的，迅速的expeditiously adv.迅速地please expedite the shipment of fruit,as it is perishable .水果易于腐烂，所以请迅速装运。3.expedient（将脚向外迈ex(=out) + ped(=foot)）adj.方便的，便利的；权宜之计的；得当的；可取的n.临时的措施，权宜之计；简便的方法expedience /expediency 便利；权宜之计；有利expediently adv.便利地；权宜地It is expedient to apply to numerous universities rather than just your favorite. 申请多个学校要比只申请你最喜欢的学校有利一些。4.dispatch（使脚分开走dis (=apart) + patch&lt;ped(=foot)）vt.快递；派遣；匆匆吃完；杀死n.派遣；快递；急件，快信；迅速，急速；杀死The executive dispatched a letter to the Chicago field office by overnight express.那位高级官员用隔夜快递向位于芝加哥的驻地机构发送了一封信件。5.inexpedientadj.不适当的，不适宜的 *in(=not),ex(=out),ped(=foot)inexpediency n.不适当6.pedaln.（自行车、织布机、缝纫机、钢琴等的）脚踏板adj.踏板的；脚的v.踩踏板；骑自行车 *ped(=foot)pedal cyclists 骑脚踏自行车的人；pedal away on his bicycle 骑上他的自行车离开7.peddlev.沿街叫卖；散播（流言等） *ped(=foot)peddle gossip round the village 在村里到处散播流言蜚语8.peddlingadj.无关紧要的；叫卖的 *ped(=foot)9.peddlern.小贩；传播（流言）的人 *ped(=foot)pedlar/pedler(=peddler)10.pedestaln.（雕像等的）底座；柱脚 *ped(=foot),stal(=put)11.pedestriann.步行者adj.徒步的，步行的；（文章、演讲方式等）枯燥无味的，平淡的 *ped(=foot)pedestrians killed traffic accidents 死于交通事故的步行者pedestrian crossing 人行横道pedestrian bridge 人行天桥pedestrian precinct 步行区域pedestrian speech 平淡无奇的演说12.pedicuren.足疗；修脚指甲（&lt;–&gt;manicure 护理（手））*ped(=foot),cur(=take care)13.pedigreen.家谱；家世，血统adj.纯种的 *ped(=foot),ig(=drive)family pedigree 家系，家谱pedigree cattle 纯种的牛pedigree poodle 纯种卷毛狮子狗14.pedometern.计步器,步程计 *ped(=foot),meter(=measure)15.bipedn. 两足动物 *ped(=foot),bi(=two)16.quadrupedn.四足动物 *ped(=foot),quadru(=four)17.centipeden.蜈蚣；百足 *ped(=foot),cent(hundred)18.millipeden.千足虫 *ped(=foot),*mill(=thousand)19.multiped (=multipede)n.多足adj. 多足的20.tripodn.三脚（架）adj.三脚的 《tri- = three》21.decapodn.十腕亚目动物（如鱿鱼等）；十足目动物（如蟹、虾等）*deca (=ten),pod&lt;ped(=foot)22.chiropodistn.手足病医生 *chiro(=hand),pod&lt;ped(=foot) cf.chiropody 手足医术 ✓ 0x02 计算机相关领域 1.Pod简介在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.一个Pod（就像一群鲸鱼，或者一个豌豆夹）相当于一个共享context的配置组，在同一个context下，应用可能还会有独立的cgroup隔离机制，一个Pod是一个容器环境下的“逻辑主机”，它可能包含一个或者多个紧密相连的应用，这些应用可能是在同一个物理主机或虚拟机上。[PS.] K8s可近似看作主机独立进程的模式进行节点管理,因此逻辑主机可以看作是服务管理的最小调度单元Pod 的context可以理解成多个linux命名空间的联合PID 命名空间（同一个Pod中应用可以看到其它进程）网络 命名空间（同一个Pod的中的应用对相同的IP地址和端口有权限）IPC 命名空间（同一个Pod中的应用可以通过VPC或者POSIX进行通信）UTS 命名空间（同一个Pod中的应用共享一个主机名称）同一个Pod中的应用可以共享磁盘，磁盘是Pod级的，应用可以通过文件系统调用，额外的，一个Pod可能会定义顶级的cgroup隔离，这样的话绑定到任何一个应用（好吧，这句是在没怎么看懂，就是说Pod，应用，隔离）[PS.]理解逻辑主机概念，其实逻辑主机共享磁盘应该能够理解 ✓ 0x03 十分意向化理解 AirPodsAirPods --&gt; AirPod --&gt; Pod --&gt; AirAirPods的演化能够很能get到(豌豆荚和足)的概念, 不知道为什么之前不理解pod，直到看到这个，瞬间刺激到了。","categories":[{"name":"朝花夕拾","slug":"朝花夕拾","permalink":"http://acrofrank.github.io/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://acrofrank.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"词汇","slug":"词汇","permalink":"http://acrofrank.github.io/tags/%E8%AF%8D%E6%B1%87/"},{"name":"英语","slug":"英语","permalink":"http://acrofrank.github.io/tags/%E8%8B%B1%E8%AF%AD/"}]}]}