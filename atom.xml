<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MYBLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.acropanda.top/"/>
  <updated>2019-12-11T09:47:06.375Z</updated>
  <id>blog.acropanda.top/</id>
  
  <author>
    <name>Acrofrank &#39;s Blog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫项目记录--搜索引擎图片爬取(一)</title>
    <link href="blog.acropanda.top/2019/12/03/log-spider-project-0/"/>
    <id>blog.acropanda.top/2019/12/03/log-spider-project-0/</id>
    <published>2019-12-03T14:50:32.000Z</published>
    <updated>2019-12-11T09:47:06.375Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="爬虫项目记录搜索引擎图片爬取"><a class="markdownIt-Anchor" href="#爬虫项目记录搜索引擎图片爬取"></a> 爬虫项目记录–搜索引擎图片爬取</h1><h2 id="log-my-v2ex-crawl-pic-from-se-1"><a class="markdownIt-Anchor" href="#log-my-v2ex-crawl-pic-from-se-1"></a> Log my v2ex – crawl pic from SE (1)</h2><h2 id="记录爬虫项目-爬取搜索引擎图片一"><a class="markdownIt-Anchor" href="#记录爬虫项目-爬取搜索引擎图片一"></a> 记录爬虫项目 – 爬取搜索引擎图片（一）</h2><p><code>前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。</code></p><p>感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。</p><h3 id="0x00-关于爬虫的认识"><a class="markdownIt-Anchor" href="#0x00-关于爬虫的认识"></a> ✓ 0x00 关于爬虫的认识</h3><h4 id="1-工程化的爬虫"><a class="markdownIt-Anchor" href="#1-工程化的爬虫"></a> <strong>1. 工程化的爬虫</strong></h4><p>用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。</p><p>常见的爬虫框架有很多，如下：</p><p><strong>开源的Web爬虫</strong><br><a id="more"></a></p><table><thead><tr><th>项目名</th><th>开发语言</th><th>平台</th></tr></thead><tbody><tr><td>Heritrix</td><td>Java</td><td>Linux</td></tr><tr><td>Nutch</td><td>Java</td><td>Cross-platform</td></tr><tr><td>Scrapy</td><td>Python</td><td>Cross-platform</td></tr><tr><td>DataparkSearch</td><td>C++</td><td>Cross-platform</td></tr><tr><td>Headless chrome crawler</td><td>nodejs</td><td></td></tr><tr><td>Colly</td><td>Golang</td><td>Cross-platform</td></tr><tr><td>GNU Wget</td><td>C</td><td>Linux</td></tr><tr><td>GRUB</td><td>C#, C, Python, Perl</td><td>Cross-platform</td></tr><tr><td>ht://Dig</td><td>C++</td><td>Unix</td></tr><tr><td>HTTrack</td><td>C/C++</td><td>Cross-platform</td></tr><tr><td>ICDL Crawler</td><td>C++</td><td>Cross-platform</td></tr><tr><td>mnoGoSearch</td><td>C</td><td>Windows</td></tr></tbody></table><p>其中，python栈的Scrapy，Java栈的Nutch，Golang栈的Colly， 以及Linux平台的wget想必爬虫工程师基本都有所耳闻。</p><p>wget通常只是在Linux上测试环境，或者应用做一些运维方向的包下载。</p><p>对比Scrapy和Nutch就很有意思了，Scrapy是python语言的，秉承python的便捷性，能沟通快速、简单、可扩展的方式去抓取你的网页内容。<br>Nutch是老大哥Apache旗下的成熟的爬虫框架，通常结合Solr索引数据，能够实现简易的搜索引擎。</p><pre><code>PS: 之前工作应用Scrapy有段时间，其实关于Scrapy也好很多弊端都是语言上的弊端，毕竟python是解释性语言，    对机器的使用效率肯定没有java高。但是个人觉得Scrapy的设计和实现确实能够满足日常需求。通常玩Python    有个问题就是所谓动态一时爽，重构火葬场。其实这句话在Scrapy的代码上也有体现。尤其是在为了增加各种    插件，效率更是惨不忍睹。Twisted作为事件驱动引擎并发性也并没有那么高效。虽然支持扩展，通常业界都是    redis-scrapy消息队列的通信方式进行分布式爬虫，这块可能也是python的弊端，python虽然是胶水语言，    但是，个人感觉在分布式的领域，python真的不是很擅长。    （以上个人观点）</code></pre><p>通常的爬虫框架都具备了如下特点：</p><ol><li>为了更快速获取到相应数据，爬虫都具有分布式的可扩展性；</li><li>会应用语言栈中相对高并发的网络的框架去支撑爬虫引擎，提升请求效率；</li></ol><h3 id="0x01-关于爬虫的设计"><a class="markdownIt-Anchor" href="#0x01-关于爬虫的设计"></a> ✓ 0x01 关于爬虫的设计</h3><p>其实上文提到了要么提高单个应用的网络并发提高网络请求，要么通过分布式的方式调度单体程序，实现提高请求数量。除了这些，能够保证爬虫的完成工作在实际工况下还不能够满足需求。因为现实情况并不是网络爬虫总能爬取到我们想要的数据。要考虑各种爬虫的异常情况，以增加爬虫的健壮性。因此需要明确爬虫成功获取数据都经历了哪些流程，并且需要对这些流程进行监控。</p><h4 id="1-爬虫执行任务的流程模型"><a class="markdownIt-Anchor" href="#1-爬虫执行任务的流程模型"></a> <strong>1. 爬虫执行任务的流程模型</strong></h4><ol><li><p>获取任务（需要被请求的资源地址）</p></li><li><p>目标网站发送请求</p></li><li><p>获取目标网站返回数据</p></li><li><p>解析目标网站返回数据</p></li><li><p>持久化的数据</p><p>PS: 深挖一些，其实2<sub>3可以抽象一个模块；其中涉及到一些问题，比如，一个网页的数据并不是直接以静态页或者接口数据的形势返回给爬虫，存在动态页的情况。需要加载js和多次请求才能完成需要持久化的数据，这其中变化比较大。还有可能就是，需要解析并下载视频资源或音频资源或者图片资源。还有可能需要与其他服务配合获取数据，比如通过MITM截取的数据组合可以作为这个阶段要持久化的数据。总之，2</sub>3过程可以看做是爬虫系统和网页之间交互的过程，最终输出结果是需求的数据。</p></li></ol><h4 id="2-爬虫执行任务的状态模型"><a class="markdownIt-Anchor" href="#2-爬虫执行任务的状态模型"></a> <strong>2. 爬虫执行任务的状态模型</strong></h4><p>有动作，即为有变化，有变化就会有变化的状态空间，就要能够记录其中的状态。其实以爬虫为例，通常都会记录以上1~5个过程，不考虑特殊聚合数据的情况【js渲染， MITM组合数据】，会根据上述过程进行记录。通常记录过程完成态即可（成功/失败的统计数据），还有完成态的时间。此外，爬虫通常和代理是分不开的。所以，通常也会记录代理的使用情况。以scrapy为例如下：</p><pre><code>{'downloader/request_bytes': 212,'downloader/request_count': 1,'downloader/request_method_count/GET': 1,'downloader/response_bytes': 1476,'downloader/response_count': 1,'downloader/response_status_count/200': 1,'elapsed_time_seconds': 0.160045,'finish_reason': 'finished','finish_time': datetime.datetime(2019, 12, 9, 20, 54, 6, 134329),'log_count/DEBUG': 1,'log_count/INFO': 10,'memusage/max': 44896256,'memusage/startup': 44896256,'response_received_count': 1,'scheduler/dequeued': 1,'scheduler/dequeued/memory': 1,'scheduler/enqueued': 1,'scheduler/enqueued/memory': 1,'start_time': datetime.datetime(2019, 12, 9, 20, 54, 5, 974284)}</code></pre><h4 id="3-爬虫去重"><a class="markdownIt-Anchor" href="#3-爬虫去重"></a> <strong>3. 爬虫去重</strong></h4><p>提高爬虫效率，爬虫的去重是必不可少的模块。此时需要区分爬虫是否为增量爬虫，若为增量爬虫，那么去重的粒度就会低一些，或者说去重集合的元素是有存活期的。非增量爬虫，就需要对所有资源进行去重，不仅仅有网页的URL，同时，网页上的资源如果下载也需要进行去重判断。</p><p>去重设计也有很多种：</p><ol><li>Bloomfilter 布隆过滤器（优点：节省空间， 缺点：难以复原去重源数据，不能操作过期时间）</li><li>redis Hset Set（Hset 相对 Set 节省点空间，难以操作过期时间）</li></ol><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><blockquote><p><a href="https://www.zhihu.com/question/60280580" target="_blank" rel="noopener">Python有哪些常见的、好用的爬虫框架？</a></p><p><a href="https://blog.csdn.net/pop_xiaohao/article/details/76571871" target="_blank" rel="noopener">爬虫那些事－爬虫设计思路</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;爬虫项目记录搜索引擎图片爬取&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#爬虫项目记录搜索引擎图片爬取&quot;&gt;&lt;/a&gt; 爬虫项目记录–搜索引擎图片爬取&lt;/h1&gt;&lt;h2 id=&quot;log-my-v2ex-crawl-pic-from-se-1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#log-my-v2ex-crawl-pic-from-se-1&quot;&gt;&lt;/a&gt; Log my v2ex – crawl pic from SE (1)&lt;/h2&gt;&lt;h2 id=&quot;记录爬虫项目-爬取搜索引擎图片一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记录爬虫项目-爬取搜索引擎图片一&quot;&gt;&lt;/a&gt; 记录爬虫项目 – 爬取搜索引擎图片（一）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。&lt;/p&gt;&lt;h3 id=&quot;0x00-关于爬虫的认识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-关于爬虫的认识&quot;&gt;&lt;/a&gt; ✓ 0x00 关于爬虫的认识&lt;/h3&gt;&lt;h4 id=&quot;1-工程化的爬虫&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-工程化的爬虫&quot;&gt;&lt;/a&gt; &lt;strong&gt;1. 工程化的爬虫&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。&lt;/p&gt;&lt;p&gt;常见的爬虫框架有很多，如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;开源的Web爬虫&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程" scheme="blog.acropanda.top/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="blog.acropanda.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="项目" scheme="blog.acropanda.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="设计" scheme="blog.acropanda.top/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Spider" scheme="blog.acropanda.top/tags/Spider/"/>
    
      <category term="搜索" scheme="blog.acropanda.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>2019-2020读书清单</title>
    <link href="blog.acropanda.top/2019/11/26/booklist-20191126/"/>
    <id>blog.acropanda.top/2019/11/26/booklist-20191126/</id>
    <published>2019-11-25T19:14:52.000Z</published>
    <updated>2019-11-25T20:54:47.790Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="todo-list技术书籍-2019-2020"><a class="markdownIt-Anchor" href="#todo-list技术书籍-2019-2020"></a> TODO LIST–技术书籍 2019-2020</h1><h2 id="月度需要读完的书籍清单"><a class="markdownIt-Anchor" href="#月度需要读完的书籍清单"></a> 月度需要读完的书籍清单</h2><p>目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。</p><h3 id="0x00-核心阅读"><a class="markdownIt-Anchor" href="#0x00-核心阅读"></a> ✓ 0x00 核心阅读</h3><h4 id="linux-unix系统编程手册上-下册"><a class="markdownIt-Anchor" href="#linux-unix系统编程手册上-下册"></a> Linux-UNIX系统编程手册（上、下册）</h4><blockquote><p>主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。</p></blockquote><h4 id="鸟哥私房菜"><a class="markdownIt-Anchor" href="#鸟哥私房菜"></a> 鸟哥私房菜</h4><blockquote><p>一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。</p><a id="more"></a></blockquote><h4 id="docker-容器与容器云第2版"><a class="markdownIt-Anchor" href="#docker-容器与容器云第2版"></a> Docker 容器与容器云（第2版）</h4><blockquote><p>浙大SEL实验室出品的书。感觉应该是国内最早接触Docker相关技术的一批学院风的人们编写的。所以从溯源的角度去系统性了解下。</p></blockquote><h4 id="纪念版-kubernetes权威指南-从docker到kubernetes实践全接触"><a class="markdownIt-Anchor" href="#纪念版-kubernetes权威指南-从docker到kubernetes实践全接触"></a> (纪念版) Kubernetes权威指南 从Docker到Kubernetes实践全接触</h4><blockquote><p>主要目标：作为实践应用指导</p></blockquote><h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4><blockquote><p>暂时还是碎片化的知识，暂时没什么计划，网络相关的总是很繁杂。继续寻找通信相关的能够激发网络设计思考的书籍。</p></blockquote><h3 id="0x01-扩展阅读"><a class="markdownIt-Anchor" href="#0x01-扩展阅读"></a> ✓ 0x01 扩展阅读</h3><p>之前在搞人人后端的时候，因为搞了段C++接触到中科大的编译系统透视：图解编译原理这本书，扩展这本书的团队新设计出版的相关书籍还是很能解决当下自身面对的问题，所以继续扩展研究新设计团队出版的资料。有人说30岁之后就不在适合系统学习了，所以趁着机会抓紧积累。</p><h4 id="编译系统透视图解编译原理"><a class="markdownIt-Anchor" href="#编译系统透视图解编译原理"></a> 编译系统透视：图解编译原理</h4><blockquote><p>页数较多，但是自己坚持读完。其实光是看完前100页就已经收益匪浅了。</p></blockquote><h4 id="linux内核设计的艺术图解linux操作系统架构设计与实现原理"><a class="markdownIt-Anchor" href="#linux内核设计的艺术图解linux操作系统架构设计与实现原理"></a> Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理</h4><blockquote><p>还没有读，暂时作为交叉阅读系统编程手册的原理延伸阅读。</p></blockquote><h3 id="0x02-其他阅读"><a class="markdownIt-Anchor" href="#0x02-其他阅读"></a> ✓ 0x02 其他阅读</h3><h4 id="git系列"><a class="markdownIt-Anchor" href="#git系列"></a> Git系列</h4><blockquote><p>虽然明确Git的基本操作，还是希望结合文件系统深入认识下Git。说来最近也是巧了，在看肖臻老师讲区块链的视频，意识到Merkle Tree对分布式效验的重要性。深刻感受到现在知识在网络上传播的便捷性。继续进行深化交叉阅读提高认识吧。</p></blockquote><p><strong><code>It was the best of times, it was the worst of times.</code></strong> – <em>A Tale of Two Cities</em></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;todo-list技术书籍-2019-2020&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#todo-list技术书籍-2019-2020&quot;&gt;&lt;/a&gt; TODO LIST–技术书籍 2019-2020&lt;/h1&gt;&lt;h2 id=&quot;月度需要读完的书籍清单&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#月度需要读完的书籍清单&quot;&gt;&lt;/a&gt; 月度需要读完的书籍清单&lt;/h2&gt;&lt;p&gt;目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。&lt;/p&gt;&lt;h3 id=&quot;0x00-核心阅读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-核心阅读&quot;&gt;&lt;/a&gt; ✓ 0x00 核心阅读&lt;/h3&gt;&lt;h4 id=&quot;linux-unix系统编程手册上-下册&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux-unix系统编程手册上-下册&quot;&gt;&lt;/a&gt; Linux-UNIX系统编程手册（上、下册）&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;鸟哥私房菜&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#鸟哥私房菜&quot;&gt;&lt;/a&gt; 鸟哥私房菜&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="书籍" scheme="blog.acropanda.top/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="计算机" scheme="blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="学习" scheme="blog.acropanda.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="书籍" scheme="blog.acropanda.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="清单" scheme="blog.acropanda.top/tags/%E6%B8%85%E5%8D%95/"/>
    
      <category term="计划" scheme="blog.acropanda.top/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>说文解字计算机中的词汇--单词的故事系列--analog</title>
    <link href="blog.acropanda.top/2018/11/10/explain-translate-computer-related-vocabulary-analog/"/>
    <id>blog.acropanda.top/2018/11/10/explain-translate-computer-related-vocabulary-analog/</id>
    <published>2018-11-10T00:14:52.000Z</published>
    <updated>2019-11-10T10:46:48.702Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="说文解字计算机相关词汇"><a class="markdownIt-Anchor" href="#说文解字计算机相关词汇"></a> 说文解字–计算机相关词汇</h1><h2 id="explain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#explain-and-translate-computer-related-vocabulary"></a> Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事analog模拟"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事analog模拟"></a> 计算机中那些单词的故事——analog/模拟</h2><h3 id="0x00-词根词源"><a class="markdownIt-Anchor" href="#0x00-词根词源"></a> ✓ 0x00 词根词源</h3><h4 id="ana-"><a class="markdownIt-Anchor" href="#ana-"></a> <strong>ana-</strong></h4><blockquote><p>汉：来源于希腊语，意为:</p><ol><li>“up”(anabatic),</li><li>“back”(anagram),</li><li>“again”(analects),</li><li>“throughout”(analyze),</li><li>“intensive” (anatomy)等，变化型an-。<br><a id="more"></a></li></ol><p>英：before verbs an-, prefix meaning</p><ol><li>“upward,”</li><li>“back, backward, against,”</li><li>“again, anew,” from Greek ana- “up to, toward, exceedingly, back, against,” from ana “up, on, upon, throughout, again,” cognate with Old English on, from PIE root *ano- “on, upon, above” (see on).</li></ol></blockquote><h4 id="analogue-n-~-analog"><a class="markdownIt-Anchor" href="#analogue-n-~-analog"></a> <strong>analogue (n.) ~ analog</strong></h4><blockquote><p>1826, “an analogous thing,” from French analogue, from Greek analogon (itself used in English from c.1810), from ana “up to” (see ana-) + logos “account, ratio” (see lecture (n.)). <em><strong>Computing sense is recorded from 1946.</strong></em></p></blockquote><h3 id="0x01-计算机相关领域"><a class="markdownIt-Anchor" href="#0x01-计算机相关领域"></a> ✓ 0x01 计算机相关领域</h3><p><strong>操作系统：</strong></p><blockquote><p>模拟在计算机体系中的概念：<br>模拟：用软件的方法在一台现有的计算机（称为宿主机）上实现另一台计算机（称为虚拟机）的指令系统。</p></blockquote><p><strong>数字电路方向（广义）：</strong></p><blockquote><p>模拟是对真实事物或者过程的虚拟。模拟要表现出选定的物理系统或抽象系统的关键特性。模拟的关键问题包括有效信息的获取、关键特性和表现的选定、近似简化和假设的应用，以及模拟的重现度和有效性。可以认为仿真是一种重现系统外在表现的特殊的模拟。</p></blockquote><p><img src="/10/explain-translate-computer-related-vocabulary-analog/1.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;说文解字计算机相关词汇&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#说文解字计算机相关词汇&quot;&gt;&lt;/a&gt; 说文解字–计算机相关词汇&lt;/h1&gt;&lt;h2 id=&quot;explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事analog模拟&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事analog模拟&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——analog/模拟&lt;/h2&gt;&lt;h3 id=&quot;0x00-词根词源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-词根词源&quot;&gt;&lt;/a&gt; ✓ 0x00 词根词源&lt;/h3&gt;&lt;h4 id=&quot;ana-&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ana-&quot;&gt;&lt;/a&gt; &lt;strong&gt;ana-&lt;/strong&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;汉：来源于希腊语，意为:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;“up”(anabatic),&lt;/li&gt;&lt;li&gt;“back”(anagram),&lt;/li&gt;&lt;li&gt;“again”(analects),&lt;/li&gt;&lt;li&gt;“throughout”(analyze),&lt;/li&gt;&lt;li&gt;“intensive” (anatomy)等，变化型an-。&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收初识</title>
    <link href="blog.acropanda.top/2018/10/16/study-gc0/"/>
    <id>blog.acropanda.top/2018/10/16/study-gc0/</id>
    <published>2018-10-16T00:14:52.000Z</published>
    <updated>2019-12-18T18:12:34.135Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="垃圾回收基本概念"><a class="markdownIt-Anchor" href="#垃圾回收基本概念"></a> 垃圾回收基本概念</h1><h2 id="basic-garbage-collection-concepts"><a class="markdownIt-Anchor" href="#basic-garbage-collection-concepts"></a> Basic garbage collection concepts</h2><h2 id="计算机中垃圾回收的故事"><a class="markdownIt-Anchor" href="#计算机中垃圾回收的故事"></a> 计算机中垃圾回收的故事</h2><p><code>声明：本文是个人读书的感悟和知识总结。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。</code></p><p>要想认清垃圾回收最好在大脑中有了堆栈模型的情况下，了解了操作系统程序运行机制，再去认识垃圾回收就会更加深刻和彻底。（个人感悟）</p><h3 id="0x00-垃圾回收基础概念-对象-头-域"><a class="markdownIt-Anchor" href="#0x00-垃圾回收基础概念-对象-头-域"></a> ✓ 0x00 垃圾回收基础概念-【对象 /头 /域】</h3><p><strong>对象</strong>这个词，在不同的使用场合其意思各不相同。在面向对象编程中，它指“具有属性和行为的事物”，然而在 GC 的语境中，对象表示的是“<strong><em>通过应用程序利用的数据的集合</em></strong>”。</p><pre><code>· 对象配置在内存空间里。GC 根据情况将配置好的对象进行移动或销毁操作。· 对象是 GC 的基本单位。· 对象由头（header）和域（field）构成。</code></pre><h5 id="1-对象的头"><a class="markdownIt-Anchor" href="#1-对象的头"></a> 1. 对象的头</h5><p>对象中保存对象本身信息的部分称为“头”。头主要含有以下信息：</p><pre><code>· 对象的大小· 对象的种类</code></pre><h5 id="2-对象的域"><a class="markdownIt-Anchor" href="#2-对象的域"></a> 2. 对象的域</h5><p>我们把对象使用者在对象中可访问的部分称为“域”。可以将其想成 C 语言中结构体的成员。对象使用者会引用或替换对象的域值。另一方面，对象使用者基本上无法直接更改头的信息。域中的数据类型大致分为以下 2 种：</p><pre><code>· 对象的大小· 对象的种类</code></pre><img src="/16/study-gc0/ob_head_field.png" width="200" height="110" alt="对象、头以及域" align="center"><a id="more"></a><h3 id="0x01-垃圾回收基础概念-指针"><a class="markdownIt-Anchor" href="#0x01-垃圾回收基础概念-指针"></a> ✓ 0x01 垃圾回收基础概念-【指针】</h3><p>通过 GC，对象会被销毁或保留。这时候起到关键作用的就是指针。因为 GC 是根据对象的指针指向去搜寻其他对象的。另一方面，GC 对非指针不进行任何操作。</p><pre><code>· 要注意语言处理程序是否能判别指针和非指针。· 指针要指向对象的哪个部分。指针如果指向对象首地址以外的部分，GC 就会变得非常复杂。</code></pre><img src="/16/study-gc0/ob_point.png" width="300" height="150" alt="对象和指针" align="center"><h3 id="0x02-垃圾回收基础概念-mutator"><a class="markdownIt-Anchor" href="#0x02-垃圾回收基础概念-mutator"></a> ✓ 0x02 垃圾回收基础概念-【mutator】</h3><p><strong>mutator</strong> 是 Edsger Dijkstra琢磨出来的词，有“改变某物”的意思。说到要改变什么，那<strong>就是 GC 对象间的引用关系</strong>。不过光这么说可能大家还是不能理解，其实用一句话概括的话，它的实体就是“应用程序”。这样说就容易理解了吧。GC 就是在这个 <strong>mutator</strong> 内部精神饱满地工作着。<strong>mutator</strong> 实际进行的操作有以下 2 种。</p><pre><code>· 生成对象· 更新指针</code></pre><h3 id="0x03-垃圾回收基础概念-堆"><a class="markdownIt-Anchor" href="#0x03-垃圾回收基础概念-堆"></a> ✓ 0x03 垃圾回收基础概念-【堆】</h3><p><strong>堆</strong>指的是用于动态（也就是执行程序时）存放对象的内存空间。当 <strong>mutator</strong> 申请存放对象时，所需的内存空间就会从这个<strong>堆</strong>中被分配给 <strong>mutator</strong>。</p><blockquote><p>GC 是管理<strong>堆</strong>中已分配对象的机制。在开始执行 <strong>mutator</strong> 前，GC 要分配用于堆的内存空间。一旦开始执 <strong>mutator</strong>，程序就会按照** mutator** 的要求在堆中存放对象。等到<strong>堆</strong>被对象占满后，GC 就会启动，从而分配可用空间。如果不能分配足够的可用空间，一般情况下我们就要扩大<strong>堆</strong>。</p></blockquote><h3 id="0x04-垃圾回收基础概念-活动对象-非活动对象"><a class="markdownIt-Anchor" href="#0x04-垃圾回收基础概念-活动对象-非活动对象"></a> ✓ 0x04 垃圾回收基础概念-【活动对象 /非活动对象】</h3><p>将<strong>分配到内存空间中的对象</strong>中那些能通过 <strong>mutator</strong> 引用的对象称为“<strong>活动对象</strong>”。反过来，把分配到堆中那些不能通过程序引用的对象称为“<strong>非活动对象</strong>”。也就是说，不能通过程序引用的对象已经没有人搭理了，所以死掉了。死掉的对象（即<strong>非活动对象</strong>）我们就称为“垃圾”。GC 会保留活动对象，销毁<strong>非活动对象</strong>。当销毁<strong>非活动对象</strong>时，其原本占据的内存空间会得到解放，供下一个要分配的新对象使用。</p><img src="/16/study-gc0/alive_dead.png" width="400" height="150" alt="活动对象和非活动对象" align="center"><h3 id="0x05-垃圾回收基础概念-分配"><a class="markdownIt-Anchor" href="#0x05-垃圾回收基础概念-分配"></a> ✓ 0x05 垃圾回收基础概念-【分配】</h3><p><strong>分配</strong>（<strong>allocation</strong>）指的是在内存空间中分配对象。当 <strong>mutator</strong> 需要新对象时，就会向<strong>分配器</strong>（<strong>allocator</strong>）申请一个大小合适的空间。<strong>分配器</strong>则在堆的可用空间中找寻满足要求的空间，返回给 <strong>mutator</strong>。<br>当<strong>堆</strong>被所有活动对象占满时，就算运行 GC 也无法分配可用空间。为了处理如上问题：</p><pre><code>1. 销毁至今为止的所有计算结果，输出错误信息2. 扩大堆，分配可用空间</code></pre><h3 id="0x06-垃圾回收基础概念-分块"><a class="markdownIt-Anchor" href="#0x06-垃圾回收基础概念-分块"></a> ✓ 0x06 垃圾回收基础概念-【分块】</h3><p><strong>分块</strong>（chunk）在 GC 的世界里指的是为利用对象而事先准备出来的空间。</p><p>初始状态下，堆被一个大的分块所占据。然后，程序会根据 mutator 的要求把这个分块分割成合适的大小，作为（活动）对象使用。<strong>活动对象</strong>不久后会转化为垃圾被回收。此时，这部分被回收的内存空间再次成为分块，为下次被利用做准备。也就是说，内存里的各个区块都重复着分块→活动对象→垃圾（非活动对象）→分块→……这样的过程。</p><blockquote><p>PS. 类似于操作系统内存分配优化</p></blockquote><h3 id="0x07-垃圾回收基础概念-根"><a class="markdownIt-Anchor" href="#0x07-垃圾回收基础概念-根"></a> ✓ 0x07 垃圾回收基础概念-【根】</h3><p><strong>根</strong>（<strong>root</strong>）这个词的意思是“根基”“根底”。在 GC 的世界里，<strong>根是指向对象的指针的</strong>“<strong>起点</strong>”<strong>部分</strong>。</p><h3 id="0x08-垃圾回收基础概念-垃圾回收评价标准"><a class="markdownIt-Anchor" href="#0x08-垃圾回收基础概念-垃圾回收评价标准"></a> ✓ 0x08 垃圾回收基础概念-【垃圾回收评价标准】</h3><p>评价 GC 算法的性能时，通常采用以下 4 个标准。</p><pre><code>• 吞吐量• 最大暂停时间• 堆使用效率• 访问的局部性</code></pre><h6 id="1吞吐量"><a class="markdownIt-Anchor" href="#1吞吐量"></a> 1.吞吐量</h6><p>从一般意义上来讲，吞吐量（throughput）指的是“在单位时间内的处理能力”。</p><img src="/16/study-gc0/mutator_exe.png" width="500" height="160" alt="根和堆里的对象" align="center"><blockquote><p>在 mutator 整个执行过程中，GC 一共启动了 3 次，我们把花费的时间分别设为 A、B、C。<br>也就是说，GC 总共花费的时间为（A ＋ B ＋ C）。同时，以 GC 为对象的堆大小是 HEAP_SIZE。也就是说，在大小为 HEAP_SIZE 的堆进行内存管理，要花费的时长为（A ＋ B ＋ C）。因此，这种情况下 GC 的吞吐量为HEAP_SIZE /（A ＋ B ＋ C）。</p></blockquote><h6 id="2最大暂停时间"><a class="markdownIt-Anchor" href="#2最大暂停时间"></a> 2.最大暂停时间</h6><p>几乎所有 GC 算法，都会在 GC 执行过程中令 mutator 暂停执行。最大暂停时间指的是“因执行 GC 而暂停执行 mutator 的最长时间”。</p><blockquote><p>PS. 可以认为 <strong>GC</strong> 和<strong>检活</strong>是两个阶段。暂停会影响程序效率，结论就是最大暂停时间越小越好。</p></blockquote><h6 id="3堆使用效率"><a class="markdownIt-Anchor" href="#3堆使用效率"></a> 3.堆使用效率</h6><p>根据 GC 算法的差异，堆使用效率也大相径庭。左右堆使用效率的因素有两个。<br>一个是头的大小，另一个是堆的用法。</p><blockquote><p>首先是头的大小。在堆中堆放的信息越多，GC 的效率也就越高，吞吐量也就随之得到改善。但毋庸置疑，头越小越好。因此为了执行 GC，需要把在头中堆放的信息控制在最小限度。</p><p>其次，根据堆的用法，堆使用效率也会出现巨大的差异。举个例子，GC 复制算法中将堆二等分，每次只使用一半，交替进行，因此总是只能利用堆的一半。相对而言，GC 标记 -<br>清除算法和引用计数法就能利用整个堆。</p><p>结论就是：可用的堆越大，GC 运行越快；相反，越想有效地利用有限的堆，GC 花费的时间就越长。</p></blockquote><h6 id="4访问的局部性"><a class="markdownIt-Anchor" href="#4访问的局部性"></a> 4.访问的局部性</h6><p>具有引用关系的对象之间通常很可能存在连续访问的情况。这在多数程序中都很常见，称为“访问的局部性”。考虑到访问的局部性，把具有引用关系的对象安排在堆中较近的位置，就能提高在缓存中读取到想利用的数据的概率，令 mutator 高速运行。</p><h4 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h4><blockquote><p>[1] 垃圾回收的算法与实现 [日] 中村成洋</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;垃圾回收基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#垃圾回收基本概念&quot;&gt;&lt;/a&gt; 垃圾回收基本概念&lt;/h1&gt;&lt;h2 id=&quot;basic-garbage-collection-concepts&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#basic-garbage-collection-concepts&quot;&gt;&lt;/a&gt; Basic garbage collection concepts&lt;/h2&gt;&lt;h2 id=&quot;计算机中垃圾回收的故事&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中垃圾回收的故事&quot;&gt;&lt;/a&gt; 计算机中垃圾回收的故事&lt;/h2&gt;&lt;p&gt;&lt;code&gt;声明：本文是个人读书的感悟和知识总结。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;要想认清垃圾回收最好在大脑中有了堆栈模型的情况下，了解了操作系统程序运行机制，再去认识垃圾回收就会更加深刻和彻底。（个人感悟）&lt;/p&gt;&lt;h3 id=&quot;0x00-垃圾回收基础概念-对象-头-域&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-垃圾回收基础概念-对象-头-域&quot;&gt;&lt;/a&gt; ✓ 0x00 垃圾回收基础概念-【对象 /头 /域】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;这个词，在不同的使用场合其意思各不相同。在面向对象编程中，它指“具有属性和行为的事物”，然而在 GC 的语境中，对象表示的是“&lt;strong&gt;&lt;em&gt;通过应用程序利用的数据的集合&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;· 对象配置在内存空间里。GC 根据情况将配置好的对象进行移动或销毁操作。

· 对象是 GC 的基本单位。

· 对象由头（header）和域（field）构成。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-对象的头&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-对象的头&quot;&gt;&lt;/a&gt; 1. 对象的头&lt;/h5&gt;&lt;p&gt;对象中保存对象本身信息的部分称为“头”。头主要含有以下信息：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;· 对象的大小

· 对象的种类
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;2-对象的域&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2-对象的域&quot;&gt;&lt;/a&gt; 2. 对象的域&lt;/h5&gt;&lt;p&gt;我们把对象使用者在对象中可访问的部分称为“域”。可以将其想成 C 语言中结构体的成员。对象使用者会引用或替换对象的域值。另一方面，对象使用者基本上无法直接更改头的信息。域中的数据类型大致分为以下 2 种：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;· 对象的大小

· 对象的种类
&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;/16/study-gc0/ob_head_field.png&quot; width=&quot;200&quot; height=&quot;110&quot; alt=&quot;对象、头以及域&quot; align=&quot;center&quot;&gt;
    
    </summary>
    
    
      <category term="学习" scheme="blog.acropanda.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="垃圾回收" scheme="blog.acropanda.top/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="算法" scheme="blog.acropanda.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="读书笔记" scheme="blog.acropanda.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="GC" scheme="blog.acropanda.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（一）</title>
    <link href="blog.acropanda.top/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/"/>
    <id>blog.acropanda.top/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/</id>
    <published>2018-10-15T00:14:52.000Z</published>
    <updated>2019-12-18T18:19:14.737Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="remix说文解字计算机相关词汇git相关"><a class="markdownIt-Anchor" href="#remix说文解字计算机相关词汇git相关"></a> [Remix]说文解字–计算机相关词汇–Git相关</h1><h2 id="remixexplain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#remixexplain-and-translate-computer-related-vocabulary"></a> (Remix)Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事git系列一"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事git系列一"></a> 计算机中那些单词的故事——Git系列(一)</h2><p><code>声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。</code></p><p>本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态</p><h3 id="0x00-git-历史与简介"><a class="markdownIt-Anchor" href="#0x00-git-历史与简介"></a> ✓ 0x00 Git 历史与简介</h3><p>提到 <strong>Git</strong> 就离不开版本控制，<strong>版本控制</strong><em>是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</em></p><blockquote><p>[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。</p></blockquote><h4 id="版本控制系统大致可以分为"><a class="markdownIt-Anchor" href="#版本控制系统大致可以分为"></a> 版本控制系统大致可以分为：</h4><p><a href="#1.1">1.本地版本控制系统</a></p><p><a href="#1.2">2.集中化的版本控制系统</a></p><p><a href="#1.3">3.分布式版本控制系统</a></p><p><strong><span id="1.1">1.本地版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的<br>好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><a id="more"></a> <img src="/15/remix-explain-translate-computer-related-vocabulary-git/本地版本控制f1.png" width="300" height="300" alt="图片名称"><p><strong>解决办法</strong>：应用某种简单的数据库来记录文件的历次更新差异。</p></blockquote><p><strong><span id="1.2">2.集中化的版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统<br>（<em>Centralized Version Control Systems</em>，简称 <strong>CVCS</strong>）应运而生。</p><img src="/15/remix-explain-translate-computer-related-vocabulary-git/集中化的版本控制f2.png" width="350" height="350" alt="图片名称"><p><strong>解决办法</strong>：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p></blockquote><p><strong><span id="1.3">3.分布式版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。</p><blockquote><p>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p></blockquote><img src="/15/remix-explain-translate-computer-related-vocabulary-git/分布式版本控制f3.png" width="400" height="400" alt="图片名称"><p><strong>解决办法</strong>：分布式版本控制系统（<em><strong>Distributed Version Control System</strong></em>，简称 <strong>DVCS</strong>）能够完美解决集中管理系统的问题。像_<strong>Git</strong>_、<strong><em>Mercurial</em></strong>、<strong><em>Bazaar</em></strong> 以及 <strong><em>Darcs</em></strong> 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p><blockquote><p>[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。</p></blockquote></blockquote><h4 id="git相比其他版本控制系统的优势"><a class="markdownIt-Anchor" href="#git相比其他版本控制系统的优势"></a> <strong>Git相比其他版本控制系统的优势</strong></h4><p><a href="#2.1">1.Git 直接记录快照，而非差异比较</a></p><p><a href="#2.2">2.Git 近乎所有操作都是本地执行</a></p><p><a href="#2.3">3.Git 保证完整性</a></p><p><a href="#2.4">4.Git 一般只添加数据</a></p><p><strong><span id="2.1">1.Git 直接记录快照，而非差异比较</span></strong></p><blockquote><p>Git 和其它版本控制系统（包括 <strong>Subversion</strong> 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（<strong>CVS、Subversion、Perforce、Bazaar</strong> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><img src="/15/remix-explain-translate-computer-related-vocabulary-git/存储每个文件与初始版本的差异f5.png" width="450" height="250" alt="存储每个文件与初始版本的差异"><p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p><img src="/15/remix-explain-translate-computer-related-vocabulary-git/存储项目随时间改变的快照f5.png" width="450" height="250" alt="存储项目随时间改变的快照"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。</p><blockquote><p>[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子</p></blockquote></blockquote><p><strong><span id="2.2">2.Git 近乎所有操作都是本地执行</span></strong></p><blockquote><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><blockquote><p>[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。</p></blockquote></blockquote><p><strong><span id="2.3">3.Git 保证完整性</span></strong></p><blockquote><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<strong>这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学</strong>。若你在传送过程中丢失信息或损坏文件，Git 也能发现。</p><p>Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内<br>容的哈希值来索引，而不是文件名。</p><blockquote><p>24b9da6552252987aa493b52f8696cd6d3b00373</p></blockquote><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></blockquote><p><strong><span id="2.4">4.Git 一般只添加数据</span></strong></p><blockquote><p>执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><blockquote><p>[P.S] <strong>Git</strong> 和系统编程的极客和大牛脱不开关系</p></blockquote></blockquote><h4 id="git本地的三种状态"><a class="markdownIt-Anchor" href="#git本地的三种状态"></a> Git本地的三种状态</h4><blockquote><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交（committed）、已修改（modified）和已暂存（staged）</strong>。<strong>已提交</strong>表示数据已经安全的保存在本地数据库中。<strong>已修改</strong>表示修改了文件，但还没保存到数据库中。<strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>有状态变量就会有状态空间，Git项目的三个工作区域的概念：<strong>工作目录</strong>、<strong>Git仓库</strong>以及<strong>暂存区域</strong>。</p><img src="/15/remix-explain-translate-computer-related-vocabulary-git/工作目录、暂存区域以及Git仓库f6.png" width="450" height="250" alt="工作目录、暂存区域以及Git仓库"><p><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域</p><p><strong>Git仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p></blockquote><h5 id="基本的git工作流程如下"><a class="markdownIt-Anchor" href="#基本的git工作流程如下"></a> 基本的Git工作流程如下：</h5><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><blockquote><p>如果 Git 目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>。</p><p>[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。</p></blockquote><h3 id="0x01-git-中的单词-附"><a class="markdownIt-Anchor" href="#0x01-git-中的单词-附"></a> ✓ 0x01 Git 中的单词 (附)</h3><h4 id="git-help"><a class="markdownIt-Anchor" href="#git-help"></a> <strong>git --help</strong></h4><blockquote><p><strong>add</strong> – Add file contents to the index</p><p><strong>bisect</strong> – Find by binary search the change that introduced a bug</p><p><strong>branch</strong> – List, create, or delete branches</p><p><strong>checkout</strong> – Checkout a branch or paths to the working tree</p><p><strong>clone</strong> – Clone a repository into a new directory</p><p><strong>commit</strong> – Record changes to the repository</p><p><strong>diff</strong> – Show changes between commits, commit and working tree, etc</p><p><strong>fetch</strong> – Download objects and refs from another repository</p><p><strong>grep</strong> – Print lines matching a pattern</p><p><strong>init</strong> – Create an empty Git repository or reinitialize an existing one</p><p><strong>log</strong> – Show commit logs</p><p><strong>merge</strong> – Join two or more development histories together</p><p><strong>mv</strong> – Move or rename a file, a directory, or a symlink</p><p><strong>pull</strong> – Fetch from and merge with another repository or a local branch</p><p><strong>push</strong> – Update remote refs along with associated objects</p><p><strong>rebase</strong> – Forward-port local commits to the updated upstream head</p><p><strong>reset</strong> – Reset current HEAD to the specified state</p><p><strong>rm</strong> – Remove files from the working tree and from the index</p><p><strong>show</strong> – Show various types of objects</p><p><strong>status</strong> – Show the working tree status</p><p><strong>tag</strong> – Create, list, delete or verify a tag object signed with GPG</p></blockquote><h4 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h4><p>[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress<br>[2] Manual of Git</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;remix说文解字计算机相关词汇git相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remix说文解字计算机相关词汇git相关&quot;&gt;&lt;/a&gt; [Remix]说文解字–计算机相关词汇–Git相关&lt;/h1&gt;&lt;h2 id=&quot;remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; (Remix)Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事git系列一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事git系列一&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——Git系列(一)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态&lt;/p&gt;&lt;h3 id=&quot;0x00-git-历史与简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-git-历史与简介&quot;&gt;&lt;/a&gt; ✓ 0x00 Git 历史与简介&lt;/h3&gt;&lt;p&gt;提到 &lt;strong&gt;Git&lt;/strong&gt; 就离不开版本控制，&lt;strong&gt;版本控制&lt;/strong&gt;&lt;em&gt;是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/em&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;版本控制系统大致可以分为&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#版本控制系统大致可以分为&quot;&gt;&lt;/a&gt; 版本控制系统大致可以分为：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.本地版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.2&quot;&gt;2.集中化的版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.3&quot;&gt;3.分布式版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;1.1&quot;&gt;1.本地版本控制系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的&lt;br&gt;好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="git" scheme="blog.acropanda.top/tags/git/"/>
    
      <category term="workflow" scheme="blog.acropanda.top/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>说文解字计算机中的词汇--单词的故事系列--pod</title>
    <link href="blog.acropanda.top/2018/10/10/explain-translate-computer-related-vocabulary-pod/"/>
    <id>blog.acropanda.top/2018/10/10/explain-translate-computer-related-vocabulary-pod/</id>
    <published>2018-10-10T00:14:52.000Z</published>
    <updated>2019-12-18T17:06:40.846Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --><h1 id="说文解字计算机相关词汇"><a class="markdownIt-Anchor" href="#说文解字计算机相关词汇"></a> 说文解字–计算机相关词汇</h1><h2 id="explain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#explain-and-translate-computer-related-vocabulary"></a> Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事pod-pod-豌豆荚足"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事pod-pod-豌豆荚足"></a> 计算机中那些单词的故事——pod/-pod-(豌豆荚/足)</h2><h3 id="0x00-词根词源"><a class="markdownIt-Anchor" href="#0x00-词根词源"></a> ✓ 0x00 词根词源</h3><h4 id="1pod-n1"><a class="markdownIt-Anchor" href="#1pod-n1"></a> <strong>1.<a href="http://www.etymon.cn/origins/p/29504.html" target="_blank" rel="noopener">pod (n.1)</a></strong></h4><blockquote><p>“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.</p><p>最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。</p><img src="/10/explain-translate-computer-related-vocabulary-pod/bean.jpg" width="200" height="200" alt="图片名称" align="center"><a id="more"></a></blockquote><h4 id="2词根pedpodpuspeachpatchpet-foot足"><a class="markdownIt-Anchor" href="#2词根pedpodpuspeachpatchpet-foot足"></a> <strong>2.<a href="http://www.etymon.cn/yingyucigen/1856.html" target="_blank" rel="noopener">词根ped(pod,pus,peach,patch,pet) = foot（足）</a></strong></h4><blockquote><p>1.impediment（把脚放在里面im&lt;in(=in) + ped(=foot)）<br>n.妨碍，障碍；（口吃等）语言障碍<br>impede v.妨碍，阻碍<br>impedimenta n.（行李等）妨碍行进的重负<br>Overcrowded,uncomfortable classrooms are an impediment to learning .过于拥挤的、不舒适的教室会妨碍学习。</p><p>2.expedite（将脚向外迈ex(=out) + ped(foot)）<br>vt.促进，加速（行动、进程等）快速执行，迅速处理<br>expedition n.探险（队），远征（队）；迅速，敏捷<br>expeditionary adj.探险的，远征的<br>expeditious 敏捷的，迅速的<br>expeditiously adv.迅速地<br>please expedite the shipment of fruit,as it is perishable .水果易于腐烂，所以请迅速装运。</p><p>3.expedient（将脚向外迈ex(=out) + ped(=foot)）<br>adj.方便的，便利的；权宜之计的；得当的；可取的<br>n.临时的措施，权宜之计；简便的方法<br>expedience /expediency 便利；权宜之计；有利<br>expediently adv.便利地；权宜地<br>It is expedient to apply to numerous universities rather than just your favorite. 申请多个学校要比只申请你最喜欢的学校有利一些。</p><p>4.dispatch（使脚分开走dis (=apart) + patch&lt;ped(=foot)）<br>vt.快递；派遣；匆匆吃完；杀死<br>n.派遣；快递；急件，快信；迅速，急速；杀死<br>The executive dispatched a letter to the Chicago field office by overnight express.那位高级官员用隔夜快递向位于芝加哥的驻地机构发送了一封信件。</p><p>5.inexpedient<br>adj.不适当的，不适宜的 *in(=not),ex(=out),ped(=foot)<br>inexpediency n.不适当</p><p>6.pedal<br>n.（自行车、织布机、缝纫机、钢琴等的）脚踏板<br>adj.踏板的；脚的<br>v.踩踏板；骑自行车 *ped(=foot)<br>pedal cyclists 骑脚踏自行车的人；pedal away on his bicycle 骑上他的自行车离开</p><p>7.peddle<br>v.沿街叫卖；散播（流言等） *ped(=foot)<br>peddle gossip round the village 在村里到处散播流言蜚语</p><p>8.peddling<br>adj.无关紧要的；叫卖的 *ped(=foot)</p><p>9.peddler<br>n.小贩；传播（流言）的人 *ped(=foot)<br>pedlar/pedler(=peddler)</p><p>10.pedestal<br>n.（雕像等的）底座；柱脚 *ped(=foot),stal(=put)</p><p>11.pedestrian<br>n.步行者<br>adj.徒步的，步行的；（文章、演讲方式等）枯燥无味的，平淡的 *ped(=foot)<br>pedestrians killed traffic accidents 死于交通事故的步行者<br>pedestrian crossing 人行横道<br>pedestrian bridge 人行天桥<br>pedestrian precinct 步行区域<br>pedestrian speech 平淡无奇的演说</p><p>12.pedicure<br>n.足疗；修脚指甲（&lt;–&gt;manicure 护理（手））*ped(=foot),cur(=take care)</p><p>13.pedigree<br>n.家谱；家世，血统<br>adj.纯种的 *ped(=foot),ig(=drive)<br>family pedigree 家系，家谱<br>pedigree cattle 纯种的牛<br>pedigree poodle 纯种卷毛狮子狗</p><p>14.pedometer<br>n.计步器,步程计 *ped(=foot),meter(=measure)</p><p>15.biped<br>n. 两足动物 *ped(=foot),bi(=two)</p><p>16.quadruped<br>n.四足动物 *ped(=foot),quadru(=four)</p><p>17.centipede<br>n.蜈蚣；百足 *ped(=foot),cent(hundred)</p><p>18.millipede<br>n.千足虫 *ped(=foot),*mill(=thousand)</p><p>19.multiped (=multipede)<br>n.多足<br>adj. 多足的</p><p>20.tripod<br>n.三脚（架）adj.三脚的 《tri- = three》</p><p>21.decapod<br>n.十腕亚目动物（如鱿鱼等）；十足目动物（如蟹、虾等）*deca (=ten),pod&lt;ped(=foot)</p><p>22.chiropodist<br>n.手足病医生 *chiro(=hand),pod&lt;ped(=foot) cf.chiropody 手足医术</p></blockquote><h3 id="0x02-计算机相关领域"><a class="markdownIt-Anchor" href="#0x02-计算机相关领域"></a> ✓ 0x02 计算机相关领域</h3><h4 id="1pod简介"><a class="markdownIt-Anchor" href="#1pod简介"></a> <strong>1.<a href="https://www.kubernetes.org.cn/kubernetes-pod" target="_blank" rel="noopener">Pod简介</a></strong></h4><blockquote><p>在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.</p><img src="/10/explain-translate-computer-related-vocabulary-pod/k8spod.jpg" width="200" height="200" alt="图片名称" align="center"><p>一个Pod（就像一群鲸鱼，或者一个豌豆夹）相当于一个共享context的配置组，在同一个context下，应用可能还会有独立的cgroup隔离机制，一个Pod是一个容器环境下的“<strong>逻辑主机</strong>”，它可能包含一个或者多个紧密相连的应用，这些应用可能是在同一个物理主机或虚拟机上。</p><p>[PS.] K8s可近似看作<strong>主机独立进程的模式</strong>进行节点管理,因此逻辑主机可以看作是服务管理的最小调度单元</p><p>Pod 的context可以理解成多个linux命名空间的联合</p><p>PID 命名空间（同一个Pod中应用可以看到其它进程）<br>网络 命名空间（同一个Pod的中的应用对相同的IP地址和端口有权限）<br>IPC 命名空间（同一个Pod中的应用可以通过VPC或者POSIX进行通信）<br>UTS 命名空间（同一个Pod中的应用共享一个主机名称）<br>同一个Pod中的应用可以共享磁盘，磁盘是Pod级的，应用可以通过文件系统调用，额外的，一个Pod可能会定义顶级的cgroup隔离，这样的话绑定到任何一个应用（好吧，这句是在没怎么看懂，就是说Pod，应用，隔离）</p><p>[PS.]理解逻辑主机概念，其实逻辑主机共享磁盘应该能够理解</p></blockquote><h3 id="0x03-十分意向化理解"><a class="markdownIt-Anchor" href="#0x03-十分意向化理解"></a> ✓ 0x03 十分意向化理解</h3><h4 id="airpods"><a class="markdownIt-Anchor" href="#airpods"></a> AirPods</h4><blockquote><p>AirPods --&gt; AirPod --&gt; Pod --&gt; Air<br>AirPods的演化能够很能get到(豌豆荚和足)的概念, 不知道为什么之前不理解pod，直到看到这个，瞬间刺激到了。</p></blockquote><table><tr><td><center><img src="/10/explain-translate-computer-related-vocabulary-pod/airpods.png" width="170" height="200" alt="AirPods">fig.1 AirPods</center></td><td><center><img src="/10/explain-translate-computer-related-vocabulary-pod/airpod.png" width="170" height="200" alt="AirPod">fig.2 AirPod</center></td></tr><tr><td><center><img src="/10/explain-translate-computer-related-vocabulary-pod/pod.png" width="170" height="200" alt="Pod">fig.3 Pod</center></td><td><center><img src="/10/explain-translate-computer-related-vocabulary-pod/air.png" width="170" height="200" alt="Air">fig.4 Air</center></td></tr></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 19 2019 02:27:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;说文解字计算机相关词汇&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#说文解字计算机相关词汇&quot;&gt;&lt;/a&gt; 说文解字–计算机相关词汇&lt;/h1&gt;&lt;h2 id=&quot;explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事pod-pod-豌豆荚足&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事pod-pod-豌豆荚足&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——pod/-pod-(豌豆荚/足)&lt;/h2&gt;&lt;h3 id=&quot;0x00-词根词源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-词根词源&quot;&gt;&lt;/a&gt; ✓ 0x00 词根词源&lt;/h3&gt;&lt;h4 id=&quot;1pod-n1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1pod-n1&quot;&gt;&lt;/a&gt; &lt;strong&gt;1.&lt;a href=&quot;http://www.etymon.cn/origins/p/29504.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pod (n.1)&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.&lt;/p&gt;&lt;p&gt;最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。&lt;/p&gt;&lt;img src=&quot;/10/explain-translate-computer-related-vocabulary-pod/bean.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
</feed>
