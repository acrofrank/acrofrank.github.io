<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MYBLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.acropanda.top/"/>
  <updated>2019-12-09T21:46:22.717Z</updated>
  <id>http://blog.acropanda.top/</id>
  
  <author>
    <name>Acrofrank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫项目记录--搜索引擎图片爬取(0)</title>
    <link href="http://blog.acropanda.top/2019/12/03/log-spider-project-0/"/>
    <id>http://blog.acropanda.top/2019/12/03/log-spider-project-0/</id>
    <published>2019-12-03T14:50:32.000Z</published>
    <updated>2019-12-09T21:46:22.717Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="爬虫项目记录搜索引擎图片爬取"><a class="markdownIt-Anchor" href="#爬虫项目记录搜索引擎图片爬取"></a> 爬虫项目记录–搜索引擎图片爬取</h1><h2 id="log-my-v2ex-crawl-pic-from-se-0"><a class="markdownIt-Anchor" href="#log-my-v2ex-crawl-pic-from-se-0"></a> Log my v2ex – crawl pic from SE (0)</h2><h2 id="记录爬虫项目-爬取搜索引擎图片0"><a class="markdownIt-Anchor" href="#记录爬虫项目-爬取搜索引擎图片0"></a> 记录爬虫项目 – 爬取搜索引擎图片（0）</h2><p><code>前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。</code></p><p>感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。</p><h3 id="0x00-关于爬虫的认识"><a class="markdownIt-Anchor" href="#0x00-关于爬虫的认识"></a> ✓ 0x00 关于爬虫的认识</h3><h4 id="1-工程化的爬虫"><a class="markdownIt-Anchor" href="#1-工程化的爬虫"></a> <strong>1. 工程化的爬虫</strong></h4><p>用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。</p><p>常见的爬虫框架有很多，如下：</p><p><strong>开源的Web爬虫</strong><br><a id="more"></a></p><table><thead><tr><th>项目名</th><th>开发语言</th><th>平台</th></tr></thead><tbody><tr><td>Heritrix</td><td>Java</td><td>Linux</td></tr><tr><td>Nutch</td><td>Java</td><td>Cross-platform</td></tr><tr><td>Scrapy</td><td>Python</td><td>Cross-platform</td></tr><tr><td>DataparkSearch</td><td>C++</td><td>Cross-platform</td></tr><tr><td>Headless chrome crawler</td><td>nodejs</td><td></td></tr><tr><td>Colly</td><td>Golang</td><td>Cross-platform</td></tr><tr><td>GNU Wget</td><td>C</td><td>Linux</td></tr><tr><td>GRUB</td><td>C#, C, Python, Perl</td><td>Cross-platform</td></tr><tr><td>ht://Dig</td><td>C++</td><td>Unix</td></tr><tr><td>HTTrack</td><td>C/C++</td><td>Cross-platform</td></tr><tr><td>ICDL Crawler</td><td>C++</td><td>Cross-platform</td></tr><tr><td>mnoGoSearch</td><td>C</td><td>Windows</td></tr></tbody></table><p>其中，python栈的Scrapy，Java栈的Nutch，Golang栈的Colly， 以及Linux平台的wget想必爬虫工程师基本都有所耳闻。</p><p>wget通常只是在Linux上测试环境，或者应用做一些运维方向的包下载。</p><p>对比Scrapy和Nutch就很有意思了，Scrapy是python语言的，秉承python的便捷性，能沟通快速、简单、可扩展的方式去抓取你的网页内容。<br>Nutch是老大哥Apache旗下的成熟的爬虫框架，通常结合Solr索引数据，能够实现简易的搜索引擎。</p><pre><code>PS: 之前工作应用Scrapy有段时间，其实关于Scrapy也好很多弊端都是语言上的弊端，毕竟python是解释性语言，    对机器的使用效率肯定没有java高。但是个人觉得Scrapy的设计和实现确实能够满足日常需求。通常玩Python    有个问题就是所谓动态一时爽，重构火葬场。其实这句话在Scrapy的代码上也有体现。尤其是在为了增加各种    插件，效率更是惨不忍睹。Twisted作为事件驱动引擎并发性也并没有那么高效。虽然支持扩展，通常业界都是    redis-scrapy消息队列的通信方式进行分布式爬虫，这块可能也是python的弊端，python虽然是胶水语言，    但是，个人感觉在分布式的领域，python真的不是很擅长。    （以上个人观点）</code></pre><p>通常的爬虫框架都具备了如下特点：</p><ol><li>为了更快速获取到相应数据，爬虫都具有分布式的可扩展性；</li><li>会应用语言栈中相对高并发的网络的框架去支撑爬虫引擎，提升请求效率；</li></ol><h3 id="0x01-关于爬虫的设计"><a class="markdownIt-Anchor" href="#0x01-关于爬虫的设计"></a> ✓ 0x01 关于爬虫的设计</h3><p>其实上文提到了要么提高单个应用的网络并发提高网络请求，要么通过分布式的方式调度单体程序，实现提高请求数量。除了这些，能够保证爬虫的完成工作在实际工况下还不能够满足需求。因为现实情况并不是网络爬虫总能爬取到我们想要的数据。要考虑各种爬虫的异常情况，以增加爬虫的健壮性。因此需要明确爬虫成功获取数据都经历了哪些流程，并且需要对这些流程进行监控。</p><h4 id="1-爬虫执行任务的流程模型"><a class="markdownIt-Anchor" href="#1-爬虫执行任务的流程模型"></a> <strong>1. 爬虫执行任务的流程模型</strong></h4><ol><li><p>获取任务（需要被请求的资源地址）</p></li><li><p>目标网站发送请求</p></li><li><p>获取目标网站返回数据</p></li><li><p>解析目标网站返回数据</p></li><li><p>持久化的数据</p><p>PS: 深挖一些，其实2<sub>3可以抽象一个模块；其中涉及到一些问题，比如，一个网页的数据并不是直接以静态页或者接口数据的形势返回给爬虫，存在动态页的情况。需要加载js和多次请求才能完成需要持久化的数据，这其中变化比较大。还有可能就是，需要解析并下载视频资源或音频资源或者图片资源。还有可能需要与其他服务配合获取数据，比如通过MITM截取的数据组合可以作为这个阶段要持久化的数据。总之，2</sub>3过程可以看做是爬虫系统和网页之间交互的过程，最终输出结果是需求的数据。</p></li></ol><h4 id="2-爬虫执行任务的状态模型"><a class="markdownIt-Anchor" href="#2-爬虫执行任务的状态模型"></a> <strong>2. 爬虫执行任务的状态模型</strong></h4><p>有动作，即为有变化，有变化就会有变化的状态空间，就要能够记录其中的状态。其实以爬虫为例，通常都会记录以上1~5个过程，不考虑特殊聚合数据的情况【js渲染， MITM组合数据】，会根据上述过程进行记录。通常记录过程完成态即可（成功/失败的统计数据），还有完成态的时间。此外，爬虫通常和代理是分不开的。所以，通常也会记录代理的使用情况。以scrapy为例如下：</p><pre><code>{'downloader/request_bytes': 212,'downloader/request_count': 1,'downloader/request_method_count/GET': 1,'downloader/response_bytes': 1476,'downloader/response_count': 1,'downloader/response_status_count/200': 1,'elapsed_time_seconds': 0.160045,'finish_reason': 'finished','finish_time': datetime.datetime(2019, 12, 9, 20, 54, 6, 134329),'log_count/DEBUG': 1,'log_count/INFO': 10,'memusage/max': 44896256,'memusage/startup': 44896256,'response_received_count': 1,'scheduler/dequeued': 1,'scheduler/dequeued/memory': 1,'scheduler/enqueued': 1,'scheduler/enqueued/memory': 1,'start_time': datetime.datetime(2019, 12, 9, 20, 54, 5, 974284)}</code></pre><h4 id="3-爬虫去重"><a class="markdownIt-Anchor" href="#3-爬虫去重"></a> <strong>3. 爬虫去重</strong></h4><p>提高爬虫效率，爬虫的去重是必不可少的模块。此时需要区分爬虫是否为增量爬虫，若为增量爬虫，那么去重的粒度就会低一些，或者说去重集合的元素是有存活期的。非增量爬虫，就需要对所有资源进行去重，不仅仅有网页的URL，同时，网页上的资源如果下载也需要进行去重判断。</p><p>去重设计也有很多种：</p><ol><li>Bloomfilter 布隆过滤器（优点：节省空间， 缺点：难以复原去重源数据，不能操作过期时间）</li><li>redis Hset Set（Hset 相对 Set 节省点空间，难以操作过期时间）</li></ol><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><blockquote><p><a href="https://www.zhihu.com/question/60280580" target="_blank" rel="noopener">Python有哪些常见的、好用的爬虫框架？</a></p><p><a href="https://blog.csdn.net/pop_xiaohao/article/details/76571871" target="_blank" rel="noopener">爬虫那些事－爬虫设计思路</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;爬虫项目记录搜索引擎图片爬取&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#爬虫项目记录搜索引擎图片爬取&quot;&gt;&lt;/a&gt; 爬虫项目记录–搜索引擎图片爬取&lt;/h1&gt;&lt;h2 id=&quot;log-my-v2ex-crawl-pic-from-se-0&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#log-my-v2ex-crawl-pic-from-se-0&quot;&gt;&lt;/a&gt; Log my v2ex – crawl pic from SE (0)&lt;/h2&gt;&lt;h2 id=&quot;记录爬虫项目-爬取搜索引擎图片0&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记录爬虫项目-爬取搜索引擎图片0&quot;&gt;&lt;/a&gt; 记录爬虫项目 – 爬取搜索引擎图片（0）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;前言：本文取向于设计分布式爬虫以及爬虫实战相关的思路介绍，关于一些个人工作经验和认识，需求分析，模块拆解去构建爬虫，包含了一些设计思路和解决办法。也欢迎同行交流沟通。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;感谢师兄提供的项目需求，也让我体会到数据市场的水有多深，也算是对爬虫和数据有了新的认识。&lt;/p&gt;&lt;h3 id=&quot;0x00-关于爬虫的认识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-关于爬虫的认识&quot;&gt;&lt;/a&gt; ✓ 0x00 关于爬虫的认识&lt;/h3&gt;&lt;h4 id=&quot;1-工程化的爬虫&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-工程化的爬虫&quot;&gt;&lt;/a&gt; &lt;strong&gt;1. 工程化的爬虫&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;用一句话来讲，工程化的爬虫系统不同于平时写的脚本，主要原因是由于对于爬虫的监控和调度的逻辑远比写爬虫解析的逻辑要复杂的多。复杂程度和普通的后台系统没有什么区别，甚至比一些后台系统还要复杂。&lt;/p&gt;&lt;p&gt;常见的爬虫框架有很多，如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;开源的Web爬虫&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程" scheme="http://blog.acropanda.top/categories/%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="http://blog.acropanda.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="项目" scheme="http://blog.acropanda.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="设计" scheme="http://blog.acropanda.top/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Spider" scheme="http://blog.acropanda.top/tags/Spider/"/>
    
      <category term="搜索" scheme="http://blog.acropanda.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>2019-2020读书清单</title>
    <link href="http://blog.acropanda.top/2019/11/26/booklist-20191126/"/>
    <id>http://blog.acropanda.top/2019/11/26/booklist-20191126/</id>
    <published>2019-11-25T19:14:52.000Z</published>
    <updated>2019-11-25T20:54:47.790Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="todo-list技术书籍-2019-2020"><a class="markdownIt-Anchor" href="#todo-list技术书籍-2019-2020"></a> TODO LIST–技术书籍 2019-2020</h1><h2 id="月度需要读完的书籍清单"><a class="markdownIt-Anchor" href="#月度需要读完的书籍清单"></a> 月度需要读完的书籍清单</h2><p>目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。</p><h3 id="0x00-核心阅读"><a class="markdownIt-Anchor" href="#0x00-核心阅读"></a> ✓ 0x00 核心阅读</h3><h4 id="linux-unix系统编程手册上-下册"><a class="markdownIt-Anchor" href="#linux-unix系统编程手册上-下册"></a> Linux-UNIX系统编程手册（上、下册）</h4><blockquote><p>主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。</p></blockquote><h4 id="鸟哥私房菜"><a class="markdownIt-Anchor" href="#鸟哥私房菜"></a> 鸟哥私房菜</h4><blockquote><p>一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。</p><a id="more"></a></blockquote><h4 id="docker-容器与容器云第2版"><a class="markdownIt-Anchor" href="#docker-容器与容器云第2版"></a> Docker 容器与容器云（第2版）</h4><blockquote><p>浙大SEL实验室出品的书。感觉应该是国内最早接触Docker相关技术的一批学院风的人们编写的。所以从溯源的角度去系统性了解下。</p></blockquote><h4 id="纪念版-kubernetes权威指南-从docker到kubernetes实践全接触"><a class="markdownIt-Anchor" href="#纪念版-kubernetes权威指南-从docker到kubernetes实践全接触"></a> (纪念版) Kubernetes权威指南 从Docker到Kubernetes实践全接触</h4><blockquote><p>主要目标：作为实践应用指导</p></blockquote><h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4><blockquote><p>暂时还是碎片化的知识，暂时没什么计划，网络相关的总是很繁杂。继续寻找通信相关的能够激发网络设计思考的书籍。</p></blockquote><h3 id="0x01-扩展阅读"><a class="markdownIt-Anchor" href="#0x01-扩展阅读"></a> ✓ 0x01 扩展阅读</h3><p>之前在搞人人后端的时候，因为搞了段C++接触到中科大的编译系统透视：图解编译原理这本书，扩展这本书的团队新设计出版的相关书籍还是很能解决当下自身面对的问题，所以继续扩展研究新设计团队出版的资料。有人说30岁之后就不在适合系统学习了，所以趁着机会抓紧积累。</p><h4 id="编译系统透视图解编译原理"><a class="markdownIt-Anchor" href="#编译系统透视图解编译原理"></a> 编译系统透视：图解编译原理</h4><blockquote><p>页数较多，但是自己坚持读完。其实光是看完前100页就已经收益匪浅了。</p></blockquote><h4 id="linux内核设计的艺术图解linux操作系统架构设计与实现原理"><a class="markdownIt-Anchor" href="#linux内核设计的艺术图解linux操作系统架构设计与实现原理"></a> Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理</h4><blockquote><p>还没有读，暂时作为交叉阅读系统编程手册的原理延伸阅读。</p></blockquote><h3 id="0x02-其他阅读"><a class="markdownIt-Anchor" href="#0x02-其他阅读"></a> ✓ 0x02 其他阅读</h3><h4 id="git系列"><a class="markdownIt-Anchor" href="#git系列"></a> Git系列</h4><blockquote><p>虽然明确Git的基本操作，还是希望结合文件系统深入认识下Git。说来最近也是巧了，在看肖臻老师讲区块链的视频，意识到Merkle Tree对分布式效验的重要性。深刻感受到现在知识在网络上传播的便捷性。继续进行深化交叉阅读提高认识吧。</p></blockquote><p><strong><code>It was the best of times, it was the worst of times.</code></strong> – <em>A Tale of Two Cities</em></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;todo-list技术书籍-2019-2020&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#todo-list技术书籍-2019-2020&quot;&gt;&lt;/a&gt; TODO LIST–技术书籍 2019-2020&lt;/h1&gt;&lt;h2 id=&quot;月度需要读完的书籍清单&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#月度需要读完的书籍清单&quot;&gt;&lt;/a&gt; 月度需要读完的书籍清单&lt;/h2&gt;&lt;p&gt;目前来看需要解决的问题还是系统性的朝花夕拾，主要方向是操作系统和网络。&lt;/p&gt;&lt;h3 id=&quot;0x00-核心阅读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-核心阅读&quot;&gt;&lt;/a&gt; ✓ 0x00 核心阅读&lt;/h3&gt;&lt;h4 id=&quot;linux-unix系统编程手册上-下册&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux-unix系统编程手册上-下册&quot;&gt;&lt;/a&gt; Linux-UNIX系统编程手册（上、下册）&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;主要目标：通过书籍认识系统实现，深入原理认识，能够完全认识系统提供接口，最好借此完成实现工作应用实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;鸟哥私房菜&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#鸟哥私房菜&quot;&gt;&lt;/a&gt; 鸟哥私房菜&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;一本曾经要读却没有认真地与时俱进跟进的书。目标：系统性跟进一些Linux操作应该知道，却模糊的问题和概念。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="书籍" scheme="http://blog.acropanda.top/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="计算机" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="学习" scheme="http://blog.acropanda.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="书籍" scheme="http://blog.acropanda.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="清单" scheme="http://blog.acropanda.top/tags/%E6%B8%85%E5%8D%95/"/>
    
      <category term="计划" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>说文解字计算机中的词汇--单词的故事系列--analog</title>
    <link href="http://blog.acropanda.top/2018/11/10/explain-translate-computer-related-vocabulary-analog/"/>
    <id>http://blog.acropanda.top/2018/11/10/explain-translate-computer-related-vocabulary-analog/</id>
    <published>2018-11-10T00:14:52.000Z</published>
    <updated>2019-11-10T10:46:48.702Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="说文解字计算机相关词汇"><a class="markdownIt-Anchor" href="#说文解字计算机相关词汇"></a> 说文解字–计算机相关词汇</h1><h2 id="explain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#explain-and-translate-computer-related-vocabulary"></a> Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事analog模拟"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事analog模拟"></a> 计算机中那些单词的故事——analog/模拟</h2><h3 id="0x00-词根词源"><a class="markdownIt-Anchor" href="#0x00-词根词源"></a> ✓ 0x00 词根词源</h3><h4 id="ana-"><a class="markdownIt-Anchor" href="#ana-"></a> <strong>ana-</strong></h4><blockquote><p>汉：来源于希腊语，意为:</p><ol><li>“up”(anabatic),</li><li>“back”(anagram),</li><li>“again”(analects),</li><li>“throughout”(analyze),</li><li>“intensive” (anatomy)等，变化型an-。<br><a id="more"></a></li></ol><p>英：before verbs an-, prefix meaning</p><ol><li>“upward,”</li><li>“back, backward, against,”</li><li>“again, anew,” from Greek ana- “up to, toward, exceedingly, back, against,” from ana “up, on, upon, throughout, again,” cognate with Old English on, from PIE root *ano- “on, upon, above” (see on).</li></ol></blockquote><h4 id="analogue-n-~-analog"><a class="markdownIt-Anchor" href="#analogue-n-~-analog"></a> <strong>analogue (n.) ~ analog</strong></h4><blockquote><p>1826, “an analogous thing,” from French analogue, from Greek analogon (itself used in English from c.1810), from ana “up to” (see ana-) + logos “account, ratio” (see lecture (n.)). <em><strong>Computing sense is recorded from 1946.</strong></em></p></blockquote><h3 id="0x01-计算机相关领域"><a class="markdownIt-Anchor" href="#0x01-计算机相关领域"></a> ✓ 0x01 计算机相关领域</h3><p><strong>操作系统：</strong></p><blockquote><p>模拟在计算机体系中的概念：<br>模拟：用软件的方法在一台现有的计算机（称为宿主机）上实现另一台计算机（称为虚拟机）的指令系统。</p></blockquote><p><strong>数字电路方向（广义）：</strong></p><blockquote><p>模拟是对真实事物或者过程的虚拟。模拟要表现出选定的物理系统或抽象系统的关键特性。模拟的关键问题包括有效信息的获取、关键特性和表现的选定、近似简化和假设的应用，以及模拟的重现度和有效性。可以认为仿真是一种重现系统外在表现的特殊的模拟。</p></blockquote><p><img src="/2018/11/10/explain-translate-computer-related-vocabulary-analog/1.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;说文解字计算机相关词汇&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#说文解字计算机相关词汇&quot;&gt;&lt;/a&gt; 说文解字–计算机相关词汇&lt;/h1&gt;&lt;h2 id=&quot;explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事analog模拟&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事analog模拟&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——analog/模拟&lt;/h2&gt;&lt;h3 id=&quot;0x00-词根词源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-词根词源&quot;&gt;&lt;/a&gt; ✓ 0x00 词根词源&lt;/h3&gt;&lt;h4 id=&quot;ana-&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ana-&quot;&gt;&lt;/a&gt; &lt;strong&gt;ana-&lt;/strong&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;汉：来源于希腊语，意为:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;“up”(anabatic),&lt;/li&gt;&lt;li&gt;“back”(anagram),&lt;/li&gt;&lt;li&gt;“again”(analects),&lt;/li&gt;&lt;li&gt;“throughout”(analyze),&lt;/li&gt;&lt;li&gt;“intensive” (anatomy)等，变化型an-。&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="http://blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="http://blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="http://blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（二）</title>
    <link href="http://blog.acropanda.top/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/"/>
    <id>http://blog.acropanda.top/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/</id>
    <published>2018-10-16T00:14:52.000Z</published>
    <updated>2019-11-15T04:49:23.734Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="remix说文解字计算机相关词汇git相关"><a class="markdownIt-Anchor" href="#remix说文解字计算机相关词汇git相关"></a> [Remix]说文解字–计算机相关词汇–Git相关</h1><h2 id="remixexplain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#remixexplain-and-translate-computer-related-vocabulary"></a> (Remix)Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事git系列二"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事git系列二"></a> 计算机中那些单词的故事——Git系列（二）</h2><p><code>声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。</code></p><p>本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态</p><h3 id="0x00-git-历史与简介"><a class="markdownIt-Anchor" href="#0x00-git-历史与简介"></a> ✓ 0x00 Git 历史与简介</h3><p>提到 <strong>Git</strong> 就离不开版本控制，<strong>版本控制</strong><em>是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</em></p><blockquote><p>[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。</p></blockquote><h4 id="版本控制系统大致可以分为"><a class="markdownIt-Anchor" href="#版本控制系统大致可以分为"></a> 版本控制系统大致可以分为：</h4><p><a href="#1.1">1.本地版本控制系统</a></p><p><a href="#1.2">2.集中化的版本控制系统</a></p><p><a href="#1.3">3.分布式版本控制系统</a></p><p><strong><span id="1.1">1.本地版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的<br>好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><a id="more"></a> <img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/本地版本控制f1.png" width="300" height="300" alt="图片名称" align="center"><p><strong>解决办法</strong>：应用某种简单的数据库来记录文件的历次更新差异。</p></blockquote><p><strong><span id="1.2">2.集中化的版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统<br>（<em>Centralized Version Control Systems</em>，简称 <strong>CVCS</strong>）应运而生。</p><img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/集中化的版本控制f2.png" width="350" height="350" alt="图片名称" align="center"><p><strong>解决办法</strong>：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p></blockquote><p><strong><span id="1.3">3.分布式版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。</p><blockquote><p>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p></blockquote><img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/分布式版本控制f3.png" width="400" height="400" alt="图片名称" align="center"><p><strong>解决办法</strong>：分布式版本控制系统（<em><strong>Distributed Version Control System</strong></em>，简称 <strong>DVCS</strong>）能够完美解决集中管理系统的问题。像_<strong>Git</strong>_、<strong><em>Mercurial</em></strong>、<strong><em>Bazaar</em></strong> 以及 <strong><em>Darcs</em></strong> 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p><blockquote><p>[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。</p></blockquote></blockquote><h4 id="git相比其他版本控制系统的优势"><a class="markdownIt-Anchor" href="#git相比其他版本控制系统的优势"></a> <strong>Git相比其他版本控制系统的优势</strong></h4><p><a href="#2.1">1.Git 直接记录快照，而非差异比较</a></p><p><a href="#2.2">2.Git 近乎所有操作都是本地执行</a></p><p><a href="#2.3">3.Git 保证完整性</a></p><p><a href="#2.4">4.Git 一般只添加数据</a></p><p><strong><span id="2.1">1.Git 直接记录快照，而非差异比较</span></strong></p><blockquote><p>Git 和其它版本控制系统（包括 <strong>Subversion</strong> 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（<strong>CVS、Subversion、Perforce、Bazaar</strong> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储每个文件与初始版本的差异f5.png" width="450" height="250" alt="存储每个文件与初始版本的差异" align="center"><p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p><img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/存储项目随时间改变的快照f5.png" width="450" height="250" alt="存储项目随时间改变的快照" align="center"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。</p><blockquote><p>[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子</p></blockquote></blockquote><p><strong><span id="2.2">2.Git 近乎所有操作都是本地执行</span></strong></p><blockquote><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><blockquote><p>[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。</p></blockquote></blockquote><p><strong><span id="2.3">3.Git 保证完整性</span></strong></p><blockquote><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<strong>这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学</strong>。若你在传送过程中丢失信息或损坏文件，Git 也能发现。</p><p>Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内<br>容的哈希值来索引，而不是文件名。</p><blockquote><p>24b9da6552252987aa493b52f8696cd6d3b00373</p></blockquote><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></blockquote><p><strong><span id="2.4">4.Git 一般只添加数据</span></strong></p><blockquote><p>执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><blockquote><p>[P.S] <strong>Git</strong> 和系统编程的极客和大牛脱不开关系</p></blockquote></blockquote><h4 id="git本地的三种状态"><a class="markdownIt-Anchor" href="#git本地的三种状态"></a> Git本地的三种状态</h4><blockquote><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交（committed）、已修改（modified）和已暂存（staged）</strong>。<strong>已提交</strong>表示数据已经安全的保存在本地数据库中。<strong>已修改</strong>表示修改了文件，但还没保存到数据库中。<strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>有状态变量就会有状态空间，Git项目的三个工作区域的概念：<strong>工作目录</strong>、<strong>Git仓库</strong>以及<strong>暂存区域</strong>。</p><img src="/2018/10/16/remix-explain-translate-computer-related-vocabulary-git1/工作目录、暂存区域以及Git仓库f6.png" width="450" height="250" alt="工作目录、暂存区域以及Git仓库" align="center"><p><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域</p><p><strong>Git仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p></blockquote><h5 id="基本的git工作流程如下"><a class="markdownIt-Anchor" href="#基本的git工作流程如下"></a> 基本的Git工作流程如下：</h5><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><blockquote><p>如果 Git 目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>。</p><p>[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。</p></blockquote><h3 id="0x01-git-中的单词-附"><a class="markdownIt-Anchor" href="#0x01-git-中的单词-附"></a> ✓ 0x01 Git 中的单词 (附)</h3><h4 id="git-help"><a class="markdownIt-Anchor" href="#git-help"></a> <strong>git --help</strong></h4><blockquote><p><strong>add</strong> – Add file contents to the index</p><p><strong>bisect</strong> – Find by binary search the change that introduced a bug</p><p><strong>branch</strong> – List, create, or delete branches</p><p><strong>checkout</strong> – Checkout a branch or paths to the working tree</p><p><strong>clone</strong> – Clone a repository into a new directory</p><p><strong>commit</strong> – Record changes to the repository</p><p><strong>diff</strong> – Show changes between commits, commit and working tree, etc</p><p><strong>fetch</strong> – Download objects and refs from another repository</p><p><strong>grep</strong> – Print lines matching a pattern</p><p><strong>init</strong> – Create an empty Git repository or reinitialize an existing one</p><p><strong>log</strong> – Show commit logs</p><p><strong>merge</strong> – Join two or more development histories together</p><p><strong>mv</strong> – Move or rename a file, a directory, or a symlink</p><p><strong>pull</strong> – Fetch from and merge with another repository or a local branch</p><p><strong>push</strong> – Update remote refs along with associated objects</p><p><strong>rebase</strong> – Forward-port local commits to the updated upstream head</p><p><strong>reset</strong> – Reset current HEAD to the specified state</p><p><strong>rm</strong> – Remove files from the working tree and from the index</p><p><strong>show</strong> – Show various types of objects</p><p><strong>status</strong> – Show the working tree status</p><p><strong>tag</strong> – Create, list, delete or verify a tag object signed with GPG</p></blockquote><h4 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h4><p>[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress<br>[2] Manual of Git</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;remix说文解字计算机相关词汇git相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remix说文解字计算机相关词汇git相关&quot;&gt;&lt;/a&gt; [Remix]说文解字–计算机相关词汇–Git相关&lt;/h1&gt;&lt;h2 id=&quot;remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; (Remix)Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事git系列二&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事git系列二&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——Git系列（二）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态&lt;/p&gt;&lt;h3 id=&quot;0x00-git-历史与简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-git-历史与简介&quot;&gt;&lt;/a&gt; ✓ 0x00 Git 历史与简介&lt;/h3&gt;&lt;p&gt;提到 &lt;strong&gt;Git&lt;/strong&gt; 就离不开版本控制，&lt;strong&gt;版本控制&lt;/strong&gt;&lt;em&gt;是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/em&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;版本控制系统大致可以分为&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#版本控制系统大致可以分为&quot;&gt;&lt;/a&gt; 版本控制系统大致可以分为：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.本地版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.2&quot;&gt;2.集中化的版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.3&quot;&gt;3.分布式版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;1.1&quot;&gt;1.本地版本控制系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的&lt;br&gt;好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="http://blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="http://blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="http://blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="git" scheme="http://blog.acropanda.top/tags/git/"/>
    
      <category term="workflow" scheme="http://blog.acropanda.top/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>（混合版）说文解字计算机中的词汇--单词的故事系列--git系列（一）</title>
    <link href="http://blog.acropanda.top/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/"/>
    <id>http://blog.acropanda.top/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/</id>
    <published>2018-10-15T00:14:52.000Z</published>
    <updated>2019-11-14T21:38:40.259Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="remix说文解字计算机相关词汇git相关"><a class="markdownIt-Anchor" href="#remix说文解字计算机相关词汇git相关"></a> [Remix]说文解字–计算机相关词汇–Git相关</h1><h2 id="remixexplain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#remixexplain-and-translate-computer-related-vocabulary"></a> (Remix)Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事git系列一"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事git系列一"></a> 计算机中那些单词的故事——Git系列(一)</h2><p><code>声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。</code></p><p>本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态</p><h3 id="0x00-git-历史与简介"><a class="markdownIt-Anchor" href="#0x00-git-历史与简介"></a> ✓ 0x00 Git 历史与简介</h3><p>提到 <strong>Git</strong> 就离不开版本控制，<strong>版本控制</strong><em>是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</em></p><blockquote><p>[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。</p></blockquote><h4 id="版本控制系统大致可以分为"><a class="markdownIt-Anchor" href="#版本控制系统大致可以分为"></a> 版本控制系统大致可以分为：</h4><p><a href="#1.1">1.本地版本控制系统</a></p><p><a href="#1.2">2.集中化的版本控制系统</a></p><p><a href="#1.3">3.分布式版本控制系统</a></p><p><strong><span id="1.1">1.本地版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的<br>好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><a id="more"></a> <img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/本地版本控制f1.png" width="300" height="300" alt="图片名称" align="center"><p><strong>解决办法</strong>：应用某种简单的数据库来记录文件的历次更新差异。</p></blockquote><p><strong><span id="1.2">2.集中化的版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统<br>（<em>Centralized Version Control Systems</em>，简称 <strong>CVCS</strong>）应运而生。</p><img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/集中化的版本控制f2.png" width="350" height="350" alt="图片名称" align="center"><p><strong>解决办法</strong>：通过单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p></blockquote><p><strong><span id="1.3">3.分布式版本控制系统</span></strong></p><blockquote><p><strong>问题</strong>：很明显，单一集中式管理，对集中管理产生了依赖，一旦集中管理出现问题，后果也是不堪设想。</p><blockquote><p>如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p></blockquote><img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/分布式版本控制f3.png" width="400" height="400" alt="图片名称" align="center"><p><strong>解决办法</strong>：分布式版本控制系统（<em><strong>Distributed Version Control System</strong></em>，简称 <strong>DVCS</strong>）能够完美解决集中管理系统的问题。像_<strong>Git</strong>_、<strong><em>Mercurial</em></strong>、<strong><em>Bazaar</em></strong> 以及 <strong><em>Darcs</em></strong> 等。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份.</p><blockquote><p>[P.S] 其实版本控制的历史和互联网的应用服务发展很像，从单体，集中式到分布式。直觉上，很多东西是相通的，很有意思，为了办成一件事，条件不够就创造条件。首先，在单机时，要考虑变化的维度，出现了本地版本控制；后来，为了合作，需要大家在同一个空间进行交互，增加了中心管理维度，产生了集中式版本管理。为了保证本机也会有远端的版本，本地复制了远端完整备份，也就是增加了本地备份远端的维度，这样就算远端一时挂掉，本地也会有个本地同步远端时刻的状态可以供本地基于此状态进行修改。</p></blockquote></blockquote><h4 id="git相比其他版本控制系统的优势"><a class="markdownIt-Anchor" href="#git相比其他版本控制系统的优势"></a> <strong>Git相比其他版本控制系统的优势</strong></h4><p><a href="#2.1">1.Git 直接记录快照，而非差异比较</a></p><p><a href="#2.2">2.Git 近乎所有操作都是本地执行</a></p><p><a href="#2.3">3.Git 保证完整性</a></p><p><a href="#2.4">4.Git 一般只添加数据</a></p><p><strong><span id="2.1">1.Git 直接记录快照，而非差异比较</span></strong></p><blockquote><p>Git 和其它版本控制系统（包括 <strong>Subversion</strong> 和近似工具）的主要差别在于 Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（<strong>CVS、Subversion、Perforce、Bazaar</strong> 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/存储每个文件与初始版本的差异f5.png" width="450" height="250" alt="存储每个文件与初始版本的差异" align="center"><p>Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个<strong>快照流</strong>。</p><img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/存储项目随时间改变的快照f5.png" width="450" height="250" alt="存储项目随时间改变的快照" align="center"><p>这是 Git 与几乎所有其它版本控制系统的重要区别。Git 考虑了以前每一代版本控制系统延续下来的诸多方面。</p><blockquote><p>[P.S] 怀疑因为 Linus 社区中大牛都是精通系统编程，Git 上有很多系统编程的极客技术的影子</p></blockquote></blockquote><p><strong><span id="2.2">2.Git 近乎所有操作都是本地执行</span></strong></p><blockquote><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><blockquote><p>[P.S] 确切的说，本地数据库保存了同步远端数据库的状态。</p></blockquote></blockquote><p><strong><span id="2.3">3.Git 保证完整性</span></strong></p><blockquote><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。<strong>这意味着在 Git 会记录所有任何时刻对任何文件内容或目录内容更改，这也是 Git 的哲学</strong>。若你在传送过程中丢失信息或损坏文件，Git 也能发现。</p><p>Git 用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9 和 a-f）组成字符串，基于Git 中文件的内容或目录结构计算出来。Git 数据库中保存的信息都是以文件内<br>容的哈希值来索引，而不是文件名。</p><blockquote><p>24b9da6552252987aa493b52f8696cd6d3b00373</p></blockquote><p>Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></blockquote><p><strong><span id="2.4">4.Git 一般只添加数据</span></strong></p><blockquote><p>执行 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><blockquote><p>[P.S] <strong>Git</strong> 和系统编程的极客和大牛脱不开关系</p></blockquote></blockquote><h4 id="git本地的三种状态"><a class="markdownIt-Anchor" href="#git本地的三种状态"></a> Git本地的三种状态</h4><blockquote><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交（committed）、已修改（modified）和已暂存（staged）</strong>。<strong>已提交</strong>表示数据已经安全的保存在本地数据库中。<strong>已修改</strong>表示修改了文件，但还没保存到数据库中。<strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>有状态变量就会有状态空间，Git项目的三个工作区域的概念：<strong>工作目录</strong>、<strong>Git仓库</strong>以及<strong>暂存区域</strong>。</p><img src="/2018/10/15/remix-explain-translate-computer-related-vocabulary-git/工作目录、暂存区域以及Git仓库f6.png" width="450" height="250" alt="工作目录、暂存区域以及Git仓库" align="center"><p><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作”索引“，不过一般说法还是叫暂存区域</p><p><strong>Git仓库目录</strong>是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p></blockquote><h5 id="基本的git工作流程如下"><a class="markdownIt-Anchor" href="#基本的git工作流程如下"></a> 基本的Git工作流程如下：</h5><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><blockquote><p>如果 Git 目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>。</p><p>[P.S] 虽然本地仓库与远端仓库不是实时同步，但是能够作为本地与远端通信的代理。</p></blockquote><h3 id="0x01-git-中的单词-附"><a class="markdownIt-Anchor" href="#0x01-git-中的单词-附"></a> ✓ 0x01 Git 中的单词 (附)</h3><h4 id="git-help"><a class="markdownIt-Anchor" href="#git-help"></a> <strong>git --help</strong></h4><blockquote><p><strong>add</strong> – Add file contents to the index</p><p><strong>bisect</strong> – Find by binary search the change that introduced a bug</p><p><strong>branch</strong> – List, create, or delete branches</p><p><strong>checkout</strong> – Checkout a branch or paths to the working tree</p><p><strong>clone</strong> – Clone a repository into a new directory</p><p><strong>commit</strong> – Record changes to the repository</p><p><strong>diff</strong> – Show changes between commits, commit and working tree, etc</p><p><strong>fetch</strong> – Download objects and refs from another repository</p><p><strong>grep</strong> – Print lines matching a pattern</p><p><strong>init</strong> – Create an empty Git repository or reinitialize an existing one</p><p><strong>log</strong> – Show commit logs</p><p><strong>merge</strong> – Join two or more development histories together</p><p><strong>mv</strong> – Move or rename a file, a directory, or a symlink</p><p><strong>pull</strong> – Fetch from and merge with another repository or a local branch</p><p><strong>push</strong> – Update remote refs along with associated objects</p><p><strong>rebase</strong> – Forward-port local commits to the updated upstream head</p><p><strong>reset</strong> – Reset current HEAD to the specified state</p><p><strong>rm</strong> – Remove files from the working tree and from the index</p><p><strong>show</strong> – Show various types of objects</p><p><strong>status</strong> – Show the working tree status</p><p><strong>tag</strong> – Create, list, delete or verify a tag object signed with GPG</p></blockquote><h4 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h4><p>[1] Scott Chacon, Ben Straub Pro Git (Second Edition) [M]. Apress<br>[2] Manual of Git</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;remix说文解字计算机相关词汇git相关&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remix说文解字计算机相关词汇git相关&quot;&gt;&lt;/a&gt; [Remix]说文解字–计算机相关词汇–Git相关&lt;/h1&gt;&lt;h2 id=&quot;remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#remixexplain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; (Remix)Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事git系列一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事git系列一&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——Git系列(一)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;声明：本文可能更多本着挖掘历史和记录学习的感性角度，并没有具体关于 Git 的操作讲解，后续应该会有工作流相关研读，侧重学习理解、逻辑和实际应用场景。其中有一些感性认识，如果感兴趣请留言，有错误也请指正。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;本篇文章着重 Git 发展历史，从历史场景了解版本控制系统演进，Git 作为分布式版本控制的特性以及Git基础概念–状态&lt;/p&gt;&lt;h3 id=&quot;0x00-git-历史与简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-git-历史与简介&quot;&gt;&lt;/a&gt; ✓ 0x00 Git 历史与简介&lt;/h3&gt;&lt;p&gt;提到 &lt;strong&gt;Git&lt;/strong&gt; 就离不开版本控制，&lt;strong&gt;版本控制&lt;/strong&gt;&lt;em&gt;是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/em&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;[P.S] 抛离 Git，想想你交论文的时候每次写的version*.**，也有根据时间去区分的，时间能够描述顺序，想想如果老师跟你说我觉得还是你上上上次那哪天那次给我那版还不错，因为勤劳修改版本多的同学肯定是疯了，哈哈哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;版本控制系统大致可以分为&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#版本控制系统大致可以分为&quot;&gt;&lt;/a&gt; 版本控制系统大致可以分为：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;#1.1&quot;&gt;1.本地版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.2&quot;&gt;2.集中化的版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#1.3&quot;&gt;3.分布式版本控制系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;1.1&quot;&gt;1.本地版本控制系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的&lt;br&gt;好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="http://blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="http://blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="http://blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="git" scheme="http://blog.acropanda.top/tags/git/"/>
    
      <category term="workflow" scheme="http://blog.acropanda.top/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title>说文解字计算机中的词汇--单词的故事系列--pod</title>
    <link href="http://blog.acropanda.top/2018/10/10/explain-translate-computer-related-vocabulary-pod/"/>
    <id>http://blog.acropanda.top/2018/10/10/explain-translate-computer-related-vocabulary-pod/</id>
    <published>2018-10-10T00:14:52.000Z</published>
    <updated>2019-11-13T16:00:48.968Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --><h1 id="说文解字计算机相关词汇"><a class="markdownIt-Anchor" href="#说文解字计算机相关词汇"></a> 说文解字–计算机相关词汇</h1><h2 id="explain-and-translate-computer-related-vocabulary"><a class="markdownIt-Anchor" href="#explain-and-translate-computer-related-vocabulary"></a> Explain and translate computer-related vocabulary</h2><h2 id="计算机中那些单词的故事pod-pod-豌豆荚足"><a class="markdownIt-Anchor" href="#计算机中那些单词的故事pod-pod-豌豆荚足"></a> 计算机中那些单词的故事——pod/-pod-(豌豆荚/足)</h2><h3 id="0x00-词根词源"><a class="markdownIt-Anchor" href="#0x00-词根词源"></a> ✓ 0x00 词根词源</h3><h4 id="1pod-n1"><a class="markdownIt-Anchor" href="#1pod-n1"></a> <strong>1.<a href="http://www.etymon.cn/origins/p/29504.html" target="_blank" rel="noopener">pod (n.1)</a></strong></h4><blockquote><p>“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.</p><p>最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。</p><img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/bean.jpg" width="200" height="200" alt="图片名称" align="center"><a id="more"></a></blockquote><h4 id="2词根pedpodpuspeachpatchpet-foot足"><a class="markdownIt-Anchor" href="#2词根pedpodpuspeachpatchpet-foot足"></a> <strong>2.<a href="http://www.etymon.cn/yingyucigen/1856.html" target="_blank" rel="noopener">词根ped(pod,pus,peach,patch,pet) = foot（足）</a></strong></h4><blockquote><p>1.impediment（把脚放在里面im&lt;in(=in) + ped(=foot)）<br>n.妨碍，障碍；（口吃等）语言障碍<br>impede v.妨碍，阻碍<br>impedimenta n.（行李等）妨碍行进的重负<br>Overcrowded,uncomfortable classrooms are an impediment to learning .过于拥挤的、不舒适的教室会妨碍学习。</p><p>2.expedite（将脚向外迈ex(=out) + ped(foot)）<br>vt.促进，加速（行动、进程等）快速执行，迅速处理<br>expedition n.探险（队），远征（队）；迅速，敏捷<br>expeditionary adj.探险的，远征的<br>expeditious 敏捷的，迅速的<br>expeditiously adv.迅速地<br>please expedite the shipment of fruit,as it is perishable .水果易于腐烂，所以请迅速装运。</p><p>3.expedient（将脚向外迈ex(=out) + ped(=foot)）<br>adj.方便的，便利的；权宜之计的；得当的；可取的<br>n.临时的措施，权宜之计；简便的方法<br>expedience /expediency 便利；权宜之计；有利<br>expediently adv.便利地；权宜地<br>It is expedient to apply to numerous universities rather than just your favorite. 申请多个学校要比只申请你最喜欢的学校有利一些。</p><p>4.dispatch（使脚分开走dis (=apart) + patch&lt;ped(=foot)）<br>vt.快递；派遣；匆匆吃完；杀死<br>n.派遣；快递；急件，快信；迅速，急速；杀死<br>The executive dispatched a letter to the Chicago field office by overnight express.那位高级官员用隔夜快递向位于芝加哥的驻地机构发送了一封信件。</p><p>5.inexpedient<br>adj.不适当的，不适宜的 *in(=not),ex(=out),ped(=foot)<br>inexpediency n.不适当</p><p>6.pedal<br>n.（自行车、织布机、缝纫机、钢琴等的）脚踏板<br>adj.踏板的；脚的<br>v.踩踏板；骑自行车 *ped(=foot)<br>pedal cyclists 骑脚踏自行车的人；pedal away on his bicycle 骑上他的自行车离开</p><p>7.peddle<br>v.沿街叫卖；散播（流言等） *ped(=foot)<br>peddle gossip round the village 在村里到处散播流言蜚语</p><p>8.peddling<br>adj.无关紧要的；叫卖的 *ped(=foot)</p><p>9.peddler<br>n.小贩；传播（流言）的人 *ped(=foot)<br>pedlar/pedler(=peddler)</p><p>10.pedestal<br>n.（雕像等的）底座；柱脚 *ped(=foot),stal(=put)</p><p>11.pedestrian<br>n.步行者<br>adj.徒步的，步行的；（文章、演讲方式等）枯燥无味的，平淡的 *ped(=foot)<br>pedestrians killed traffic accidents 死于交通事故的步行者<br>pedestrian crossing 人行横道<br>pedestrian bridge 人行天桥<br>pedestrian precinct 步行区域<br>pedestrian speech 平淡无奇的演说</p><p>12.pedicure<br>n.足疗；修脚指甲（&lt;–&gt;manicure 护理（手））*ped(=foot),cur(=take care)</p><p>13.pedigree<br>n.家谱；家世，血统<br>adj.纯种的 *ped(=foot),ig(=drive)<br>family pedigree 家系，家谱<br>pedigree cattle 纯种的牛<br>pedigree poodle 纯种卷毛狮子狗</p><p>14.pedometer<br>n.计步器,步程计 *ped(=foot),meter(=measure)</p><p>15.biped<br>n. 两足动物 *ped(=foot),bi(=two)</p><p>16.quadruped<br>n.四足动物 *ped(=foot),quadru(=four)</p><p>17.centipede<br>n.蜈蚣；百足 *ped(=foot),cent(hundred)</p><p>18.millipede<br>n.千足虫 *ped(=foot),*mill(=thousand)</p><p>19.multiped (=multipede)<br>n.多足<br>adj. 多足的</p><p>20.tripod<br>n.三脚（架）adj.三脚的 《tri- = three》</p><p>21.decapod<br>n.十腕亚目动物（如鱿鱼等）；十足目动物（如蟹、虾等）*deca (=ten),pod&lt;ped(=foot)</p><p>22.chiropodist<br>n.手足病医生 *chiro(=hand),pod&lt;ped(=foot) cf.chiropody 手足医术</p></blockquote><h3 id="0x02-计算机相关领域"><a class="markdownIt-Anchor" href="#0x02-计算机相关领域"></a> ✓ 0x02 计算机相关领域</h3><h4 id="1pod简介"><a class="markdownIt-Anchor" href="#1pod简介"></a> <strong>1.<a href="https://www.kubernetes.org.cn/kubernetes-pod" target="_blank" rel="noopener">Pod简介</a></strong></h4><blockquote><p>在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.</p><img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/k8spod.jpg" width="200" height="200" alt="图片名称" align="center"><p>一个Pod（就像一群鲸鱼，或者一个豌豆夹）相当于一个共享context的配置组，在同一个context下，应用可能还会有独立的cgroup隔离机制，一个Pod是一个容器环境下的“<strong>逻辑主机</strong>”，它可能包含一个或者多个紧密相连的应用，这些应用可能是在同一个物理主机或虚拟机上。</p><p>[PS.] K8s可近似看作<strong>主机独立进程的模式</strong>进行节点管理,因此逻辑主机可以看作是服务管理的最小调度单元</p><p>Pod 的context可以理解成多个linux命名空间的联合</p><p>PID 命名空间（同一个Pod中应用可以看到其它进程）<br>网络 命名空间（同一个Pod的中的应用对相同的IP地址和端口有权限）<br>IPC 命名空间（同一个Pod中的应用可以通过VPC或者POSIX进行通信）<br>UTS 命名空间（同一个Pod中的应用共享一个主机名称）<br>同一个Pod中的应用可以共享磁盘，磁盘是Pod级的，应用可以通过文件系统调用，额外的，一个Pod可能会定义顶级的cgroup隔离，这样的话绑定到任何一个应用（好吧，这句是在没怎么看懂，就是说Pod，应用，隔离）</p><p>[PS.]理解逻辑主机概念，其实逻辑主机共享磁盘应该能够理解</p></blockquote><h3 id="0x03-十分意向化理解"><a class="markdownIt-Anchor" href="#0x03-十分意向化理解"></a> ✓ 0x03 十分意向化理解</h3><h4 id="airpods"><a class="markdownIt-Anchor" href="#airpods"></a> AirPods</h4><blockquote><p>AirPods --&gt; AirPod --&gt; Pod --&gt; Air<br>AirPods的演化能够很能get到(豌豆荚和足)的概念, 不知道为什么之前不理解pod，直到看到这个，瞬间刺激到了。</p></blockquote><figure class="half"><img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/airpods.png" width="150" height="200" alt="AirPods" align="center"> <img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/airpod.png" width="150" height="200" alt="AirPod" align="center"></figure><figure class="half"><img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/pod.png" width="150" height="200" alt="Pod" align="center"> <img src="/2018/10/10/explain-translate-computer-related-vocabulary-pod/air.png" width="150" height="200" alt="Air" align="center"></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Dec 10 2019 05:46:37 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;说文解字计算机相关词汇&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#说文解字计算机相关词汇&quot;&gt;&lt;/a&gt; 说文解字–计算机相关词汇&lt;/h1&gt;&lt;h2 id=&quot;explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#explain-and-translate-computer-related-vocabulary&quot;&gt;&lt;/a&gt; Explain and translate computer-related vocabulary&lt;/h2&gt;&lt;h2 id=&quot;计算机中那些单词的故事pod-pod-豌豆荚足&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机中那些单词的故事pod-pod-豌豆荚足&quot;&gt;&lt;/a&gt; 计算机中那些单词的故事——pod/-pod-(豌豆荚/足)&lt;/h2&gt;&lt;h3 id=&quot;0x00-词根词源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0x00-词根词源&quot;&gt;&lt;/a&gt; ✓ 0x00 词根词源&lt;/h3&gt;&lt;h4 id=&quot;1pod-n1&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1pod-n1&quot;&gt;&lt;/a&gt; &lt;strong&gt;1.&lt;a href=&quot;http://www.etymon.cn/origins/p/29504.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pod (n.1)&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;“seed of beans,” 1680s, of uncertain origin; found earlier in podware “seed of legumes, seed grain” (mid-15c.), which had a parallel form codware “husked or seeded plants” (late 14c.), related to cod “husk of seeded plants,” which was in Old English. In reference to pregnancy from 1890; in reference to a round belly from 1825. Meaning “detachable body of an aircraft” is from 1950. Pod people (1956) is from movie “Invasion of the Body Snatchers,” based on novel by Jack Finney.&lt;/p&gt;&lt;p&gt;最早指代一种不确定定来源的豆类种子,1680年代； 早在豆荚“豆类种子，种子谷物”（15年代中期）中发现，其具有与鳕鱼“种子植物的外壳”有关的平行形式的鳕鱼“脱壳或有种子的植物”（14c。晚期）。 古英语。 关于1890年的怀孕； 指的是1825年的圆形肚皮。意思是“飞机的可拆卸机身”是1950年的。Pod people（1956）摘自电影《入侵车身的抢夺者》，改编自杰克·芬尼的小说。&lt;/p&gt;&lt;img src=&quot;/2018/10/10/explain-translate-computer-related-vocabulary-pod/bean.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="朝花夕拾" scheme="http://blog.acropanda.top/categories/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
    
      <category term="计算机" scheme="http://blog.acropanda.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="词汇" scheme="http://blog.acropanda.top/tags/%E8%AF%8D%E6%B1%87/"/>
    
      <category term="英语" scheme="http://blog.acropanda.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
</feed>
